# CHAPTER 3 리액트 어플리케이션 구조

[3.1 구조화되지 않은 프로젝트의 문제점](#31-구조화되지-않은-프로젝트의-문제점)  
[3.2 프론트 엔드 애플리케이션의 복잡함에 대한 이해](#32-프론트-엔드-애플리케이션의-복잡함에-대한-이해)  
[3.3 일반적인 리액트 애플리케이션 구조](#33-일반적인-리액트-애플리케이션-구조)
[3.4 프로젝트 구조를 체계적으로 유지하기](#34-프로젝트-구조를-체계적으로-유지하기)

## 3.1 구조화되지 않은 프로젝트의 문제점

- 무질서한 코드: 특정 코드 파일이나 컴포넌트를 찾기 위한 명확한 구조의 필요.
- 낮은 코드 재사용성: 재사용 가능한 컴포넌트, 기능을 식별하기 쉬운 구조의 필요. 코드 중복, 일관성 부족과 연관됨
- 협업의 어려움: 서로의 코드를 이해하고 탐색하는데 필요.
- 확장성 문제: 프로젝트 진행에 따라 기능과 규모가 커질수록 기존 코드와 통합하는데 필요.
- 복잡한 유지보수 문제: 기능 변경, 문제해결에 필요

## 3.2 프론트 엔드 애플리케이션의 복잡함에 대한 이해

프로젝트를 구성하는 대표적인 요소

- 소스코드: 애플리케이션의 핵심. 로직을 담고 있는 자바스크립트 또는 타입스크립트 파일, UI 구조를 위한 HTML 파일, 디자인을 표현하는 스타일 파일 등. 애플리케이션의 동작과 사용자 인터페이스를 정의하는 모든 것.
- 에셋: 애플리케이션에서 활용하는 이미지, 비디오, 폰트와 같은 모든 정적 파일. 애플리케이션의 시각적 경험과 상호작용을 위해 필요.
- 설정: 애플리케이션 제어와 관련된 매개변수 포함. 의존성 목록 package.json과 프로젝트 빌드시 필요한 환경 변수 등.
- 테스트: 애플리케이션의 올바른 동작과 안정성을 위해 필요. 사용자 동작을 재현하고 상호작용을 검증하며 유닛, 통합, E2E 테스트를 포함.
- 문서: 프로젝트 개요를 제공하는 README, API문서와 코드 스타일 가이드 등. 프로젝트와 연관된 사람들이 참고하여 프로젝트 이해도를 높이고 코드의 일관성.
- 빌드 결과물: 배포 가능한 최적화된 번들 자바스크립트, CSS, HTML 그리고 디버깅에 도움이 되는 진단 파일과 임시 파일들을 포함한 빌드 실행 결과물. 애플리케이션을 최종 사용자에게 전달하는 핵심 요소
- 개발 도구와 설정 파일: 코드의 품질과 일정한 포맷을 유지하고 형상 관리, 자동화된 테스팅과 배포 절차를 쉽게 해주는 도구. 백그라운드로 작업 수행, 원활하고 오류 없는 효율적 개발 과정을 제공.

프로젝트에는 다양한 파일이 존재하며, 쉽게 탐색하고 파르게 수정하기 위해서 코드베이스를 일관되게 정리하는 것이 좋다.

- 코드 요소의 이름을 짓고 구조화할 떄 일관성을 유지하는 것이 중요.
- 코드를 구조화 하고 개발 과정을 단순화 하자.

## 3.3 일반적인 리액트 애플리케이션 구조

### 3.3.1 기능 기반 구조 - 기능과 모듈 중심으로 구조화

- 구현할 기능 단위로 폴더를 분리하여 관리하며 기능마다 components, containers, pages, services, types, utils 폴더를 가지는 방식
- 공유 및 재사용이 자주 발생하는 요소들은 shared 폴더에 따로 관리

장점

- 명확한 관심사 분리
- 모듈화
- 확장성
- 팀 협업

단점

- 코드 중복의 가능성

### 3.3.2 컴포넌트 기반 구조- 재사용 가능한 컴포넌트 단위로 구조화

- 재사용 가능한 컴포넌트 단위로 폴더를 나누어 관리하며 각 컴포넌트의 조합으로 더 큰 뷰를 만들어 나가는 방식
- 각자의 컴포넌트에서는 필요한 경우 자식 컴포넌트로 세분화 하면서 계층 구조를 확장

장점

- 모듈화
- 관심사 분리
- 높은 코드 재사용성

단점

- 프로젝트 복잡도 증가: 프로젝트 규모가 조금만 커져도 폴더 구조를 단순하게 유지하기 쉽지 않다.
- 높은 진입장벽
- 코드 중복의 가능성: 기능 기반 구조에서 사용한 shared폴더 구조를 병행하는 방법 고려

### 3.3.3 아토믹 디자인 구조 - 사용자 인터페이스를 체계화

- 사용자 인터페이스를 원자(atom)라고 부르는 재사용 가능한 작은 단위로 나누며, 이를 합성하여 분자, 유기체, 템플릿, 페이지 등의 큰 단위 생성.
- UI 컴포넌트를 만드는 체계적인 접근 방식 설계. 재사용성, 확장성, 유지보수성을 높이는 것이 목표

- 원자: UI를 구성하는 가장 작은요소이며 단순하고 독립된 단일 기능을 가짐. (버튼, 인푹, 아이콘, 레이블 등)
- 분자: 원자들을 조합하여 복잡한 UI 컴포넌트 표현. 여러 원자가 상호작용하여 기능 단위 구성. (폼 입력, 내비게이션 바 등)
- 유기체: 원자, 분자를 조합하여 사용자 인터페이스의 기능 영역 UI를 포현. (헤더, 사이드바, 카드 컴포넌트 등)
- 템플릿: 분자, 유기체들을 배치하는 레이아웃 구조. 페이지 전반적인 구조와 UI의 기능영역을 표시
- 페이지: 템플릿과 유기체, 분자, 원자 등을 모두 결합한 온전한 사용자 화면 구성 전체.

장점

- 재사용성
- 일관성
- 확장성
- 유지보수성
- 쉬운 협업

단점

- 높은 진입장벽
- 복잡도
- 오버 엔지니어링

### 3.3.4 MVVM(Model-View-ViewModel) 구조 - 사용자 인터페이스를 만드는 데 사용되는 아키텍처 패턴

- 모델: 실제 다루는 데이터 또는 정보. (데이터베이스, 파일, 웹서비스, 단순 객체)
- 뷰: 사용자가 보면서 상호작용하는 것. 모델을 사용자에게 보여주는 역할
- 뷰모델: 대부분의 로직이 위치. 외부에 공개된 속성, 명렬이 있는 추상화된 뷰. 뷰-모델 사이의 차이를 메워주며 모델의 데이터를 뷰가 쉽게 처리할 수 있는 형식으로 가공. 데이터에 대한 작업을 수행, 뷰에 어떻게 보여줄지 결정.

장점

- 관심사 분리
- 쉬운 테스팅
- 높은 재사용성
- 높은 확장성

단점

- 복잡도 증가
- 높은 진입장벽

## 3.4 프로젝트 구조를 체계적으로 유지하기

`기능 기반 구조`는 프로젝트 초기에 유용한 전략. 프로젝트가 커지고 비슷한 패턴들이 반복되기 시작하면 추가 계층을 만들어 중복을 피할 수 있다.

- Login(로그인), Order(주문), Payment(결제)와 같은 기능 단위 페이지 별로 폴더 분리
- 각 페이지에 필요한 구성 요소(버튼, 입력 폼 등)을 별도로 구현

여기서 같은 형태로 재사용 되는 컴포넌트들이 중복 구현되는 현상이 반복적으로 발생할 경우 공유 컴포넌트 분리 폴더를 만들어 관리한다. 모든 컴포넌트를 여기서 관리하기 보단 재사용률이 높은 컴포넌트를 우선적으로 분리한다.

컴포넌트 이외에도 로직과 기능별로 폴더 분리를 고려해볼 수 있다.

- api: 네트워크 요청을 발생시키고 응답을 다루며 백엔드와 상호작용하는 API 관련 코드
- context: 전역 상태 관리 및 컨포넌트 간 데이터 공유 영역.
- hooks: 재사용 가능한 MV관련 로직을 담은 영역으로 주로 커스텀 훅을 위치
- mocks: 테스팅 목적의 모킹 데이터 위치
- pages: 페이지 또는 기능 단위로 폴더를 두고 하위 폴더로 세분화 하며 계층 구조 형성
