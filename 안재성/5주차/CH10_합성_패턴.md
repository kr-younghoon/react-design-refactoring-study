# CHAPTER 10 합성 패턴

[10.1 고차 컴포넌트를 통한 합성의 이해](#101-고차-컴포넌트를-통한-합성의-이해)    
[10.2 리액트 훅](#102-리액트-훅)    
~~[10.3 드롭다운 목록 컴포넌트 만들기]()~~    
[10.4 헤드리스 컴포넌트 패턴](#104-헤드리스-컴포넌트-패턴)    

## 10.1 고차 컴포넌트를 통한 합성의 이해
### 10.1.1 고차함수
`고차함수`는 `다른 함수를 인자로 받거나` `함수를 반환`하거나 `둘다`인 함수   
```javascript
// report 함수는 헤더, 제공되는 내용, 푸터를 포함하는 규격화된 리포트를 생성
// 고차 함수가 어떻게 합성 가능한 코드를 작성하는지 보여주는 코드
const report = (
  content: string,
  transformer: (s:string) => string = (s) => s
) => {
  const header = "===Header===";
  const footer = "===Footer===";

  return [header, tranformer(content), footer].join("\n")
}
```

### 10.1.2 고차 컴포넌트
`High-Order Component`는 컴포넌트를 받아 개선된 버전의 컴포넌트를 반환하는 함수   
특정 기능을 여러 컴포넌트에 재사용하고자 할 때 유용
```javascript
const checkAuthorization = () => {
  // 권한을 확인하거나 또는 로컬 스토리지를 확인해 원격 서버로 요청을 보냄
}

/* 컴포넌트를 인자로 받아 권한에 따라 전달받은 컴포넌트를 반환할지, 로그인 컴포넌트를 반환할지 결정하는 로직을 추가*/
const withAuthorization = (Component: React.FC): React.FC => {
  return (props: any) => {
    const isAuthorized = checkAuthorization();
    return isAuthorized ? <Component {...props} /> : <Login />
  }
}
```

### 10.1.3 ExpandablePanel 컴포넌트 구현하기
```javascript
// Toggleable 타입을 만족하는 컴포넌트라면 어떤 컴포넌트라도 받음
// 받은 컴포넌트에 자동닫기 기능을 적용하는 고차 컴포넌트

interface Toggleable {
  isOpen: boolean;
  toggle: () => void;
}

const withAutoClose = <T extends Partial<Toggleable>>(
  Component: React.FC<T>,
  duration: number = 2000
) => (props: T)  => {
  const [show, setShow] = useState<boolean>(true);

  useEffect(() => {
    if(show) {
      const timerId = setTimeout(() => setShow(false), duration);
      return () => clearTimeout(timerId);
    }
  }, [show]);

  return (
    <Component
    {...props}
    isOpen={show}
    toggle={() => setShow((show) => !show)}
    />
  );
}

...
// withAutoClose 고차 컴포넌트의 재사용성
const AutoDismissToast = withAutoClose(Toast, 3000);
const TimedTooltip = withAutoClose(Tooltip, 3000);
```

```javascript
// 컴포넌트에 키보드 입력에 따른 반응을 추가하는 고차 컴포넌트
// Enter, ESC

const noop= () => {};
const withKeyboardToggle = <T extends Partial<Toggleable>>(Component: React.FC<T>) =>
(props: T) => {
  const divRef = useRef<HTMLDivElement>(null);
  const handleKeyDown = (event: KeyboardEvent<HTMLDivElement>) => {
    if(event.key === 'Enter' || event.key === " " ){
      event.preventDefault();
      (props.toggle ?? noop)();
    }
    if(event.key === 'Escape' && divRef.current) {
      divRef.current.blur();
    }
  }

  return (
    <div  onKeyDown={handleKeyDown} tabIndex={0} ref={divRef}>
      <Component {...props} />
    </div>
  )
}
```
이러한 고차 컴포넌트들을 HOC Chainning 중첩 방식으로 복잡한 기능을 만들 수 있다.

```javascript
const AccessibleAutoClosePanel = withAutoClose(withKeyboardToggle(ExpandablePanel), 2000);
```


## 10.2 리액트 훅
훅은 `상태가 있는 로직을 컴포넌트에서 분리`할 수 있게 하여 `독립적인 테스팅`과 `재사용`을 가능하게 해주며 컴포넌트 구조를 바꾸지 않고도 상태가 있는 로직을 재사용할 수 있게 함. 또한 리액트의 상태 또는 기타 생명주기 기능들을 연동할 수 있다.

주요 사용 예시
- UI관련 상태 관리
- 데이터 페칭
- 페이지 단위의 키보드 단축키 처리와 같은 전역 이벤트 핸들링 등 UI 부수 효ㅕ과
- 네트워크 요청 간소화

```javascript
const ExpandablePanel = ({heading, content}: PanelProps) => {
  const {isOpen, toggle} = useAutoClose(2000);
  const {handleKeyDown} = useKeyboard(toggle);

  return (
    <article onKeyDown={handleKeyDown} tabIndex={0}>
      <header onClick={toggle}>{heading}</header>
      {isOpen && <section> {content}</section>}
    </article>
  )
}

// 타이머 훅
const useAutoClose = () => {
  const [isOpen, setIsOpen] = useState<boolean>(true);

  useEffet(() => {
    if(isOpen) {
      const timerId = setTimeout(()=> setIsOpne(false), duration);
      return clearTimeout(timerId)
    }
  },[duration, isOpen])

  const toggle = () => setIsOpen((show) => !show);

  return {isOpen, toggle};
};

// 키보드 이벤트 핸들링 훅
const useKeyBoard = (toggle: () => void) {
  const handleKeyDown = (event: KeyboardEvent => {
    if(event.key === 'Endter' || event.key ===' ') {
      event.preventDeault();
      toggle();
    }
  })
  return {hanelKeyDown}
}

```

### 10.2.1 원격 데이터 가져오기
```javascript
// 일반적인 컴포넌트 내 데이터 페칭 방식
useEffect(() => {
  const fetchData = async () => {
    setLoading(true);

    try {
      const response = await fetch('/api/users');

      if(!response.ok) {
        const error = await response.json()
        throw newError(`Error: ${error.orror} || response.status`)
      }

      const data = await response.json();
      setData(data);
    }catch (e) {
      setError(e as Error);
    }finally {
      setLoading(false)
    };
  }
  fetchData();
}, []);
```


### 10.2.2 깔끔하고 재사용성을 높이는 리팩터링
```javascript
// 위의 코드를 재사용 가능한 방법으로 분리하기
// 이 방법은 fetch함수가 고정되기 때문에 재사용하기 어려운 구조
const fetchUsers = async() => {
  const response = await fetch('/api/users');
  if(response.ok) {
    const error = await ponse.json();
    throw enw Error('Something went wrong');
  }

  return await response.json()
}

// fetch를 전달받는 훅으로 만들어 보자
const useService = <T,>(fetch: () => Promise<T>) => {
  const [loading, setLoading] = useState<boolean>(false);
  const [data, setData] = useState<T |null>(null);
  const [error, setError] = useState<Error>();

  useEffect(() => {
    const fetchData = async () => {
      setLoading(true);

      try {
        const data = await fetch();
        setData(data);
      } catch(e) {
        setError(e as Error);
      } finally {
        setLoading(false)
      }
    }

    fetchData();
  }, [fetch])

  return {
    loading,
    error,
    data
  }
}

// 이제 재사용하기 쉬운 훅이 되었다!
const {loading, error, data} = useService(fetchProducts);
const {loading, error, data} = useService(fetchTickets);
```


## 10.4 헤드리스 컴포넌트 패턴
`헤드리스 컴포넌트`는 로직을 캡슐화해서 담고 있지만 `렌더링과 관련된 것은 없는 함수`   
렌더링 영역은 사용자에게 맡김으로써, UI 렌더링에 있어서 고도의 유연성을 제공
각각 다른 형태로 UI가 필요한 영역에서 복잡한 로직을 재사용하고 싶을 때 매우 유용하다.

헤드리트 컴포넌트는 인터페이스 계층과 같다. 한쪽은 JSX뷰 영역과 상호작용/다른 쪽은 밑부분의 데이터 영역과 상호작용한다. 이는 특히 UI에서 동작과 상태 관리 측면만 시각적 표현 영역과 분리하여 다루고자 할 때 유용하다.

헤드리스 컴포넌트는 HOC, render prop 패턴으로 구현할 수 있지만, 리액트 훅으로 구현하는 것이 일반적.

```javascript
// HOC
// 장: 기존 컴포넌트에 로직을 쉽게 주입가능
// 단: HOC가 많이지면 HOC 트리가 복잡해지고 디버깅 어려움
function withCounter(WrappedComponent) {
  return function EnhancedComponent(props) {
    const [count, setCount] = React.useState(0);
    const increment = () => setCount((c) => c + 1);
    return (
      <WrappedComponent 
        {...props} 
        count={count} 
        increment={increment} 
      />
    );
  }
}

function MyButton({ count, increment }) {
  return <button onClick={increment}>Clicked {count} times</button>;
}

export default withCounter(MyButton);

// render prop
// 장: UI 자유도가 높음
// 단: children이 함수여야 해서 가독성이 떨어짐
function HeadlessCounter({ children }) {
  const [count, setCount] = React.useState(0);
  const increment = () => setCount((c) => c + 1);
  
  return children({ count, increment });
}

export default function App() {
  return (
    <HeadlessCounter>
      {({ count, increment }) => (
        <button onClick={increment}>Clicked {count} times</button>
      )}
    </HeadlessCounter>
  );
}

// react hook
// 장: 가독성이 좋고 조합이 간단
// 단: React Hook 규칙을 따라야함(컴포넌트 최상위에서만 호출, 조건문 내부 불가능 등)
function useCounter(initial = 0) {
  const [count, setCount] = React.useState(initial);
  const increment = () => setCount((c) => c + 1);
  return { count, increment };
}

export default function App() {
  const { count, increment } = useCounter();
  return <button onClick={increment}>Clicked {count} times</button>;
}
```

### 10.4.1 헤드리스 컴포넌트 장단점
장점
- 재사용성: 헤드리스 컴포넌트 패턴 내부 캡슐화된 로직은 여러 컴포넌트에서 재사용 가능. (DRY 원칙)
- 관심사 분리: 로직을 렌더링과 분리. 명확하게 관심사를 분리하여 유지보수하기 쉬운 코드의 기반.
- 유연성: UI 구현에 필요한 동일한 핵심 로직을 공유. 서로 다른 디자인 요구사항 또는 프레임워크에 적용 용이

단점
- 높은 진입장벽: 패턴에 익숙하지 않을 경우 러닝커브가 높다.
- 과도한 추상화: 관리에 주의하지 않으면 추상화 깊이에 따라 코드 추적을 어렵게 함.

### 10.4.2 지원하는 라이브러리와 추가로 알아볼 내용
- `React Aria`: 어도비에서 만든 접근성을 강조한 라이브러리. 훅 모음을 통해 키보드 상호작용, 포커싱, Aria 애너테이션 등을 다룸.

- `Headless UI`: 스타일 요소 없이 접근성을 완벽히 지원하는 UI 컴포넌트 라이브러리, tailwind css와 통합하기 편리.

- `React Table`: 리액트에서 빠르고 확장하기 편리한 테이블과 데이터 그리드를 만들 수 있는 헤드리스 유틸리티. 

- `Downshift`: 작고 가벼운 라이브러리로 접근성이 좋고 사용자 정의가 쉬운 드롭다운과 콤보 박스 UI 생성. 

#### :bulb: a11y 웹 접근성이란 
1. 법적 규제
  - 각 나라별로 접근성 표준에 맞춰야 법적 문제를 피할 수 있다.
  - 한국형 웹 콘텐츠 접근성 지침, 장애인차별금지법이 있음.

2. 포용성
  - 색각 이상, 시청각 장애인, 키보드 사용자, 스크린리더 사용자 대응

3. 사용성 개선
  - 일반 사용자 UX 개선에도 도움 (폼에 정확한 레이블 연결 등)

4. SEO와 연관
  - 검색 엔진 크롤러도 스크린리더처럼 DOM/ARIA 구조를 분석하기 때문

#### a11y 핵심 요소
1. 시맨틱 마크업
  - 의미에 맞는 HTML 태그 사용
    - \<button>, \<nav>, \<h1~6> 등
    - \<div>보다 의도에 맞는 태그를 사용하여 스크린리더의 해석을 돕자

2. 대체 텍스트(ALT)
  - `<img alt="대체 설명">` → 시각장애인 사용자도 이미지 의미를 알 수 있음.
  - 단순 장식용이면 `alt=""`로 비워야 스크린리더가 불필요하게 읽지 않음.

3. 키보드 네비게이션
  - Tab, Enter, Space, Arrow 키만으로도 모든 기능 이용 가능해야 함.
  - 포커스가 잘 이동하고 시각적으로 표시돼야 함.

4. 포커스 관리
  - 모달, 드롭다운 같은 컴포넌트에서 포커스 트랩과 포커스 복귀가 필요.
  - :focus / :focus-visible 스타일 반드시 제공.

5. 색상 대비
  - WCAG 권장 대비 비율:
  - 일반 텍스트: 최소 4.5:1
  - 큰 텍스트(18pt 이상): 최소 3:1
  - 색상만으로 상태(에러, 성공)를 구분하지 말고 아이콘/텍스트도 함께 사용.

6. ARIA 속성
  - Accessible Rich Internet Applications (ARIA)
  - 시맨틱 HTML로 표현이 부족한 경우 보완:
  - aria-label, aria-labelledby, aria-describedby → 대체 텍스트 제공
  - aria-expanded, aria-checked, aria-hidden → 상태 전달
  - role="dialog", role="menu" → 구조와 의미 전달
  -  단, ARIA는 보조 수단이지, 시맨틱 HTML을 대체하지는 않음 → 먼저 올바른 태그를 쓰는 게 중요.

7. 멀티미디어 접근성
  - 영상: 자막, 대체 텍스트 설명 제공
  - 오디오: 대본 제공

8. 반응형 디자인 + 접근성
  - 모바일 터치 대상은 최소 44px × 44px 크기 권장 (WCAG 가이드라인).