# chapter 2

## 2.5 렌더링 과정

### 1) 초기 렌더링

컴포넌트가 처음 렌더링 된 이후에 컴포넌트의 ui를 표현하는 가상의 객체를 생성

해당 객체는 UI 요소의 구조와 내용을 담고있음

### 2) 상태와 prop의 변화

상태와 Prop이 변경되면, 리액트는 함수컴포넌트를 다시 호출

이 과정에서 변경 전 결과와 현재의 실행 결과를 비교하는 알고리즘을 수행

- 내부에 있는 비교(diffing)알고리즘을 통해 데이터 변경 전후의 가상 돔 객체를 비교하여 실제 dom 변경을 최소화하는 방법을 찾음

### @ Diffing 알고리즘

실제 DOM 변경은 비용이 크고 느리기 때문에
상태가 바뀌면 새 가상 DOM과 이전 가상 DOM을 비교해 변경된 부분만 실제 DOM에 반영

1. 디핑 알고리즘의 핵심 원리

① 서로 다른 타입의 노드는 완전히 교체
이전 노드와 새 노드가 타입이 다르면(예: <div> → <p>, 또는 클래스 컴포넌트 → 함수 컴포넌트)
이전 노드를 버리고 새 노드를 새로 렌더링

② 같은 타입 노드는 속성(props)만 업데이트
노드 타입이 같으면,
속성(props)만 비교해서 변경된 부분만 실제 DOM에 반영

③ 자식 노드는 리스트 비교 (key가 매우 중요)
자식 노드가 여러 개인 경우,
React는 key를 통해 각 자식을 식별하고,
변경, 추가, 삭제된 항목을 최소한으로 찾아냄

### 3) 재조정

리액트는 비교 과정을 통해 업데이트가 필요한 UI요소를 결정 변화가 필요한 부분의 UI만을 업데이트

### 4) 리렌더링

가상 UI 요소를 업데이트하는 방식으로 리렌더링을 수행

함수의 실행 결과에 따라 가상 돔을 새로운 가상 돔으로 변경

### 5) dom 업데이트

리액트는 실제 돔에 효율적으로 가상 돔의 변경사항을 반영

추가, 삭제, 요소 업데이트와 같은 돔 조작을 통해 상태와 UI에 prop과 상태 변경 사항을 반영

이 과정은 UI가 컴포넌트의 현재 상태 및 prop과 동기화하여 데이터 변경에 동적으로 반응할 수 있도록 함

**불필요한 DOM 변경을 최소화**하여 빠르게 렌더링 될 수 있게함

⇒ 이 책을 통해 **변경되지 않는 부분은 유지하면서 필요한 부분만 다시 렌더링 하는 성능 효율적인 코드 작성법**을 알아보는것

## 2.6 리액트 훅

### 2.6.2 useEffect

두번째 매개변수는 의존하는 변수값을 토대로 부수효과를 발생시킴

부수효과 처리를 위한 핵심 기능은 **정리 함수 동작 방식**

컴포넌트가 마운트 해제될 때 리액트가 호출할 정리 함수를 반환하는 것이 좋다.

이를 통해 언마운트된 컴포넌트의 상태를 업데이트하는 등의 잠재적인 이슈를 방지하고, 메모리 누수를 예방함

### 2.6.3 useCallback

콜백 함수의 참조를 메모이제이션하고 최적화 할 때 사용

콜백 함수를 자식 컴포넌트에 전달하거나, 콜백을 다른 훅의 의존성 목록으로 지정할때 유용

```tsx
const memoizedCallback = useCallback(callback, dependencies);
```

2개의 인자

- callback : 메모이제이션 대상이 되는 함수
- dependencies: 메모이제이션하려는 콜백함수의 의존성 배열, 의존성 배열에 명시된 값이 변화하면 콜백을 다시 생성

본문의 요약 내용을 수정하는 에디터 컴포넌트
사용자가 글자를 입력할 때 마다 본문에 업데이트가 필요하며 이는 리렌더링을 발생시킴
리렌더링할 때마다 새로운 함수가 생성되며 이는 성능에 영향
useCallback을 통해 불필요한 함수 재생성을 방지하여 렌더링 과정 최적화
useCallback을 사용하면 렌더링이 발생하더라도 함수가 매번 다시 생성되지 않아, 성능 향상
