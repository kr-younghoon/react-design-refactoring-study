## 2장. 리액트 필수 개념 이해

- 챕터의 방향성

  - 프로젝트를 시작하는 데 필요한 핵심 지식 익히기

  - 특히 컴포넌트 단위로 사고하는 방법 익히기

- 챕터 주제

  - 리액트 정적 컴포넌트

  - prop이 있는 컴포넌트 만들기

  - UI를 여러 컴포넌트로 나누기

  - 리액트 내부 상태 관리

  - 렌더링 과정 이해하기

  - 많이 쓰이는 리액트 훅

---

### 리액트 정적 컴포넌트

- 정적 컴포넌트란?

  - 상태가 없고, 외부 데이터 또는 이벤트에 반응하지 않는 컴포넌트(onClick, useEffect 같은거 사용 X)

  - 프레젠테이션 컴포넌트, 더미 컴포넌트 라고 부르기도 함

  - 단순하게 prop을 전달받아 그에 맞게 UI를 렌더링하는 컴포넌트

---

### prop이 있는 컴포넌트 만들기

- prop : 다양한 데이터 또는 요구사항을 전달하여 컴포넌트를 사용자가 원하는 대로 구성할 수 있도록 도와주는 자바스크립트 객체

- prop엔 자바스크립트에서 값으로 표현할 수 있는 문자, 숫자, 불리언, 함수까지 다양한 유형의 데이터를 담을 수 있음

- prop를 컴포넌트에 전송하여 다양한 기능을 가진 범용 컴포넌트로 만들 수 있음

- prop은 가능한 5~6개를 넘지 않는 것이 코드 유지보수, 가독성 측면에서 좋음

---

### UI를 여러 컴포넌트로 나누기

- 복잡한 UI를 만들기 위해선 컴포넌트를 다루기 쉬운 작업 단위로 나누는 것이 좋음

- 예를 들면 날씨 측정 페이지를 만들때 현재 지역 날씨 컴포넌트, 시간대별 날씨 컴포넌트, 타지역 날씨 컴포넌트 등으로 여러 단위로 나누어야 애플리케이션의 전반적인 동작 흐름을 파악하기 쉽고, 오류 발생지를 발견하기 쉬워짐

- 서로 분리된 컴포넌트들 끼리 상태와 prop을 통해 데이터를 공유하고 유지해줘야 한다.

---

### 리액트 내부 상태 정리

- 리액트는 상태를 통해 컴포넌트 내부 데이터를 보관하고 관리할 수 있음

- 상태는 리액트가 사용자 액션에 반응하는 애플리케이션을 만들도록 해주는 필수 요소

#### useState훅

- 리액트의 상태를 생성해주는 훅(리액트 16.8버전 등장)

- 함수형 컴포넌트에서도 상태를 관리할 수 있게 됨

- 컴포넌트 리렌더링이 발생해도 내부의 상태를 유지할 수 있음

#### useState와 prop으로 동적인 컴포넌트 만들기

- 리액트에서 컴포넌트 내부에서 유지되는 상태와 이를 하위 컴포넌트로 전송시키는 prop을 통해 동적인 컴포넌트를 만들 수 있다.

- 리액트의 선언형 문법은 상태를 JSX에 바인딩 하고, 상태가 업데이트 된다면 해당하는 UI가 자동으로 변경되도록 만든다.

- 또, prop을 통해 하위 자식까지 부모의 상태를 사용할 수 있으며, 부모의 상태 조작으로 자식의 UI까지 동적으로 변형시킬 수 있다.

---

### 렌더링 과정 이해하기

- 리액트가 상태나 prop의 변경을 통해 렌더링을 진행할때 다음과 같은 과정을 거친다.

  - 초기 렌더링
    => 함수 컴포넌트가 최초 렌더링 된 이후에 virtual DOM을 최초 생성함

  - 상태와 prop변화
    => 상태나 prop이 변경될 시 리액트는 함수 컴포넌트를 다시 호출해 새로운 virtual DOM을 생성함
    => 그리고 이전의 virtual DOM과 비교하는 Diffing알고리즘을 통해 변경사항이 있는 노드를 발견함

  - 재조정(reconciliation)
    => Diffing을 통해 어떤 UI 요소의 업데이트가 필요한지 결정함

  - 리렌더링
    => 기존의 virtual DOM을 새로 랜더링된 virtual DOM으로 업데이트 함

  - DOM 업데이트
    => 실제 DOM에 효율적으로 가상 DOM의 변경사항만 골라 업데이트에 반영함

---

### 많이 사용되는 리액트 훅

- 네트워크 요청이나 DOM 이벤트와 같은 부수효과, 컴포넌트 간에 데이터를 공유해야 하는 상황들을 잘 다룰 수 있어야 함

- 이를 위해 리액트는 강력한 도구인 훅을 제공함

- 훅은 관심사 분리와 로직 모듈화를 통해 코드의 재사용성과 가독성을 높여주고, 컴포넌트를 쉽게 테스트 할 수 있음

#### useState

- 컴포넌트 안에서 상태를 정의하고 사용할때 사용

- 하나의 컴포넌트엔 여러개의 상태를 관리해야 하는 경우가 많음

- 로그인의 경우 ID, 비밀번호 등의 상태를 관리해야 하고, 회원가입의 경우 아이디, 비밀번호, 비밀번호 확인, 기타 개인 정보 등 여러개의 상태를 관리해야 함

- 이런 데이터들을 컴포넌트를 이용하는 동안 데이터가 사라지지 않고 유지할 수 있게 만들어줌

- 또, 만들어진 상태는 값이 변할때 마다 바인딩 된 UI도 함께 업데이트 해준다.

### useEffect

- 함수 컴포넌트 내의 부수 효과(side Effect)를 관리함

- 리액트에서 부수 효과는 컴포넌트 렌더링과 직접 관련되진 않지만, 컴포넌트 바깥 스코프에 영향을 주는 코드를 말함

- API 요청, DOM 수정, 이벤트 리스너 구독, 타이머 사용 등 외부 리소스와의 상호작용과 관련

- useEffect의 첫 번째 인자는 부수 효과를 발생시키는 콜백 함수

- useEffect의 두 번째 인자는 부수 효과를 발생시킬지 결정하는 의존성 변수 배열

- useEffect 훅의 부수 효과 처리를 위한 핵심 기능은 정리 함수(clean up function) 동작 방식임

- 컴포넌트가 언마운트 될 때 리액트가 호출할 정리 함수를 반환하는게 좋음

- setInterval 같이 컴포넌트가 종료되어도 꾸준히 실행될 동작들을 해제하는 코드를 정리 함수로 실행시켜 낭비되는 리소스가 없도록 관리해 메모리 누수가 발생하지 않도록 해줘야 함

---

### clean up function 배우면서 추가로 알게 된 거 => adortController

- abortController라는 웹API란게 있음

- 이 API는 fetch같은 비동기 데이터 요청을 취소할 수 있는 컨트롤러 기능을 제공해주는 함수임

- abortController와 useEffect의 clean up function을 조합해 모종의 이유로 컴포넌트가 언마운트 되는 경우, 기존에 실행하던 데이터 요청을 중단시켜 부수 효과(side Effect)의 발생을 줄일 수 있음

- abortController 사용법은 MDN 참조하면 잘 나옴

---

### useCallback

- 리액트 useCallback훅은 콜백 함수의 참조를 메모이제이션 할 때 사용됨

- 특히 콜백 함수를 자식 컴포넌트에 전달하거나, 콜백을 다른 훅의 의존성 목록으로 지정할 때 유용함

- 함수는 기본적으로 리렌더링이 발생할때 리렌더링과 함께 새로 생성되는데 useCallback은 설정된 함수의 참조를 따로 기억해둬 리렌더링시에도 함수를 재생성 시키지 않고 기존 참조를 계속해서 사용한다. => 렌더링 과정을 최적화 시킴

- 특히, useEffect 같은 훅의 의존성 배열의 값으로 함수가 들어가게 될 때, 리렌더링 마다 함수가 재생성되기 때문에 의존성 배열이 콜백을 재실행 시키며 무한루프가 발생할 수 있는 오류를 useCallback으로 잡을 수 있다.

- useCallback의 첫 번째 인자는 메모이제이션이 되는 함수를 담는다.

- useCallback의 두 번째 인자는 메모이제이션하려는 콜백 함수의 의존성 배열 => 의존성 배열의 값이 변경되면 메모이제이션을 풀고 함수를 새로 생성함

---

### 리액트 Context API

- 리액트 Context API는 데이터를 계층마다 일일이 prop을 통해 수동으로 전달하지 않고, 컴포넌트 하위 트리에 직접 전달할 수 있도록 해주는 기능임

- 주로 다크모드 같이 전역으로 광범위 하게 자식 컴포넌트에 prop을 전송해줘야 하는 기능에 있어 Context API를 사용함

- 이 Context API는 애플리케이션의 컴포넌트에서 접근 가능한 전역 상태를 만들고 관리함

- 특히, 각기 다른 관점의 상태를 관리하는 여러 컨텍스트 프로바이더(Context.Provider)를 조합해 애플리케이션에 제공해줄 수 있음

- 이 말은 다크모드 Provider, 로그인 Provider 등, Provider를 요소에 다중으로 감싸줌으로서 해당 영역의 컴포넌트들에게 Provider에 담긴 상태들을 전부 제공해줄 수 있다는 말

- 각각의 Provider은 관심사별로 캡슐화 하여 애플리케이션의 다른 부분에 영향을 주지 않고 상태를 업데이트하거나 관리할 수 있음
