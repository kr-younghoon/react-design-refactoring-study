## 1장. 리액트 안티패턴 소개

- 챕터의 방향성

  - 복잡한 상태 관리와 비동기 작업이 코드의 가독성을 얼마나 저해하는지 파악

  - 일반적인 안티패턴 유형들 살펴보기

- 챕터 주제

  - UI 구축의 어려움에 대한 이해

  - 상태 관리의 이해

  - 예외 흐름 살펴보기

  - 리액트의 일반적인 안티패턴 살펴보기

---

### 1-1. UI 구축의 어려움에 대한 이해

- 옛날 프론트엔드 UI는 단순한 문서를 보여주는 수준에 그쳤음

- 하지만 현대에 프론트엔드는 아코디언, 토글 스위치, 대화형 카드 등의 복잡하고 인터렉티브한 UI들이 요구됨

- 이런 UI들은 실제로 존재하는 컴포넌트들이 아니라 개발자들이 HTML, CSS, JS를 이용하여 흉내낸 것에 불가함

- 즉, 현대의 웹 페이지는 매우 복잡하고 웹 문서처럼 보이지 않지만 페이지의 구성요소는 순수한 HTML이고, CSS, JS활용 등 개발자의 구현역량과 문제해결능력 따라 UI가 무궁무진하게 변화할 수 있음

---

### 1-2. 상태 관리의 이해

- 프론트엔드에게 상태를 관리한다는 것은 매우 힘든 일이다.

- 프론트엔드과 관리해야 할 상태는 크게 서버 상태와 로컬 상태로 나뉜다.

#### 서버 상태

- 대부분의 애플리케이션은 네트워크를 통해 원격 서버에서 데이터를 가져오는데, 이를 서버 상태라고 부름

- 서버 상태는 일반적으로 백엔드 서버 또는 API와 같은 외부 소스에서 가져옴

- 이 서버 상태를 대해 몇 가지 주의사항을 지켜야 프론트 개발이 더 어려워지는걸 막을 수 있음

#### 서버 상태 사용시 주의사항

1. 비동기 특성
   - 서버 상태는 비동기적으로 가져오기 때문에 시간의 순서를 잘 파악해야함
2. 오류 처리
   - 서버 상태는 때로 실패하거나 오류를 응답할 수 있음
3. 로딩 상태
   - 서버 상태를 가져오는 동안에 로딩중 UI처리를 효과적으로 다루어야 함(fallback UI등)
4. 일관성
   - 프론트에서 변경되는 내용을 백엔드도 동기화해야함(클라이언트에서 댓글 수정했으면 서버도 수정되어야함)
5. 캐싱
   - 캐싱을 통해 일부 서버 상태를 클라이언트에 저장해 성능을 향상시킬 수 있지만 데이터 불일치, 코드 복잡도 증가 등의 문제가 발생함
6. 업데이트 및 낙관적 UI
   - 서버 상태를 가져오는 호출이 성공했을때 미리 UI를 완료된 상태로 업데이트 할 수 있지만 실패하거나 오류가 발생했을 경우 되돌리는 방법도 마련되어있어야 함

- 이건 서버 상태의 일부일 뿐이고, 이외에도 예외처리를 안할시 발생하는 문제점 등 다양한 문제가 있다.

#### 로컬 상태

- 서버 컴포넌트 뿐만 아니라 컴포넌트 내 로컬 상태관리도 신경쓸게 많음

  - UI의 동작을 결정하는 트리거나, 입력값을 종합해 보내기 위해 로컬 상태를 많이 사용하게 됨

- 서버 상태, 로컬 상태 등이 관리하기 힘들 수준으로 커진다면 Redux, Mobx와 같은 서드파티 라이브러리를 사용하는 것도 방법임

- 하지만 러닝 커브가 있고, 라이브러리마다 모범사례(Best Practice)를 익혀야 하기 때문에 서드파티 라이브러리는 신중히 고민해봐야함

- 대신 contextAPI 라는 웹 API를 활용해 상태를 전역으로 관리하는 방식이 선호되는 편임

---

### 1-3. 예외 흐름 탐색하기

- 내가 만든 UI 컴포넌트들이 원하는 방향으로 딱딱 움직이면 좋지만 현실에선 예외가 무조건 발생하게 되어있다.

- 이런 예외흐름을 무시하고 개발한 UI 컴포넌트는 생각보다 힘든 상황을 불러올 수 있다.

#### 다른 컴포넌트에서 발생한 오류

- MUI 등의 서드 파티 컴포넌트를 사용하는 경우, 해당 컴포넌트에서 발생하는 문제는 예기치 못한 사이드이펙트를 발생할 가능성이 높음

- UI화면을 망가뜨린다거나, 예상치 못한 동작이 발생한다거나...

- 이런 문제를 예방하기 위해 조건문을 추가하거나 에러 바운더리를 추가해야 하는데 그 과정에서 코드가 복잡해질 수 있음

- 에러 바운더리란?

  - 리액트에서 자식 컴포넌트의 자바스크립트 오류를 잡아 로그를 기록하고, 애플리케이션 전체가 충돌하지 않도록 fallback UI를 표시해주는 컴포넌트

  - 기본형은 클래스 객체이기 때문에 함수형 컴포넌트로 사용하고 싶다면 별도의 라이브러리를 설치해서 사용해야 함

  - 리액트의 철학이랑 어긋나서 함수형이 안만들어진다나 뭐라나...

#### 예측하지 못한 사용자 행동

- UI를 완벽하게 설계해도 사용자는 개발자의 의도를 벗어나 시스템을 활용할 수 있음

  - input창에 특수문자를 넣거나 injection코드를 짬

  - 양식을 너무 빨리 제출함 / 제출 버튼을 연타해 제출을 여러번 함

  - 브라우저 확장 프로그램을 설치해 사이트 의도에 벗어난 기능을 사용함

- 이런 사용자의 예외 처리를 신경쓰기 위해 유효성 검사, 안전 장치 등의 추가 구현을 하다 보면 UI코드는 더욱 복잡해진다.

---

### 1-4. 리액트의 일반적인 안티패턴 살펴보기

- 소프트웨어를 개발하다 보면 코드가 문제를 잘 해결해 놓은것 처럼 보이지만, 근본적인 문제를 이면에 숨겨놓은 코드들이 있다.

- 이를 안티 패턴이라고 부른다.

- 안티 패턴을 해결하지 않은 채 계속해서 개발을 이어나가면 코드는 더욱 복잡해지고, 효율이 떨어지며, 심지어 해결했다 생각한 문제도 더욱 커질 수 있음

- 이런 안티 패턴을 이해하고 인식하면 개발을 하면서 발생하는 이슈나 트러블에 대해 미리 예방할 수 있게 된다.

#### 안티 패턴 원인1 - Prop Drilling

- Prop Drilling이란 부모 컴포넌트가 자식 컴포넌트에게 상태를 prop으로 전달될때 prop을 사용하지 않는 자식 컴포넌트를 거쳐 전달되는 현상을 말함

- Prop Drilling의 문제점은 prop을 사용하지 않는 자식 컴포넌트들도 prop상태가 변경될 시 리렌더링 작업을 수행하게 되는 것임

- prop을 전송용으로만 사용되는 컴포넌트는 아무런 변경사항이 존재하지 않지만 가상돔을 생성하는 작업을 실행하게 됨 => 불필요한 비용 발생

- 이를 해결하기 위해 Redux, Mobx, Zustand 등의 전역 상태 관리를 사용하면 불필요한 렌더링을 발생시키지 않으면서 리렌더링을 진행할 수 있음

- 하지만 전역 상태를 남용하면 상태의 출처를 쉽게 특정하지 못 하는 문제점이 발생할 수 있어 contextAPI를 리렌더링 문제는 해결 못해도, prop 전송의 복잡도를 줄이는 방안으로서 자주 사용함

- contextAPI는 컴포넌트 트리의 모든 단계마다 prop을 명시적으로 전달할 필요 없이, 컴포넌트 간에 직접 데이터와 함수를 공유하는 방법을 제공해줌(하지만 해당 영역 내의 컴포넌트 전부가 리렌더링 되는건 변함없음)

#### 안티 패턴 원인 2 - 컴포넌트 내 데이터 변환

- 안티 패턴의 원인 중 하나는 UI를 담당하는 컴포넌트 내부에 복잡한 데이터 변환 로직을(비즈니스 로직) 직접 작성한다는 점이 있음

- 외부 API나 백엔드에서 전송되는 데이터는 정재되지 않은체로 오는게 대부분이라 프론트엔드가 이를 정재하는 작업을 거쳐야 함

- 그런데 이 작업을 UI를 렌더링 하는 함수 내부에 추가로 작성을 함으로써 파일 내 코드의 길이가 너무 길어지고, 가독성도 낮아짐

- 다음과 같은 문제점이 발생함

  - 명확하지 않음 -데이터 가져오기, 데이터 변환하기, 렌더링 하기 기능들이 하나의 컴포넌트에 발생해서 이 컴포넌트가 무슨 역할을 하는 컴포넌트인지 파악하기 어려움

  - 재사용성이 떨어짐

    - 다른 컴포넌트에도 유사한 비즈니스 로직이 필요하다면 비슷한 코드를 또 만들어야 하기 때문에 비용, 리소스 측면에서 낭비임

  - 테스트하기 어려움
    - 로직과 UI가 분리되지 않은 경우, 단위 테스트가 어려워진다.
    - 예를 들어 "값이 1이 출력되는지" 확인하는 테스트를 작성하려 해도, 해당 로직이 UI 렌더링 로직과 함께 섞여 있다면:
    - 테스트를 위해 렌더링 환경까지 구성해야 함 (ex. DOM, 마운트 등)
    - 비즈니스 로직만 검증하기 위해 불필요한 의존성(mock 등)을 추가해야 할 수 있음

- 따라서 비즈니스 로직은 별도의 함수나 커스텀 훅으로 분리하고, UI는 필요한 경우 @testing-library/react로 통합 시나리오 테스트를 작성하는 것이 좋음

#### 안티 패턴 원인 3 - 뷰 영역의 복잡한 로직

- 리액트의 큰 장점 중 하나는 관심사를 명확하게 분리해 줄 수 있다는 점이 있음

  - 관심사를 명확하게 분리해준다
    => UI와 로직, 상태 관리, 사이드이펙트, 데이터 흐름을 각자의 책임에 따라 분리한다는 의미

- 컴포넌트가 비즈니스 로직을 신경쓰지 않고 프레젠테이션에만 집중할 수 있도록 설계하는 것이 리액트에선 가능함

- 관심사 분리 원칙에 따라 컴포넌트의 관심사를 분리하는 것을 통해 컴포넌트를 재사용하고 유지보수하기 쉽게 만들 수 있음
  - 관심사 분리 원칙
    => 각각의 모듈 또는 함수가 애플리케이션의 하나의 기능에 대해서만 책임을 지는것

#### 안티 패턴 원인 4 - 테스트 부족

- 실수하면 치명적인 손실을 가져오는 UI나 비즈니스 로직에 대해 사전에 테스트를 진행하여 문제점을 잡아야 합니다.

- 그렇지 않으면 직접 큰 피해를 겪고 난 후에야 코드를 수정하는 상황이 발생할 수 있음

- 특히 커머스 서비스의 경우, 이런 테스트 코드가 거의 필수적으로 지켜져야 함

- 이 테스트 코드를 권장하는 개발 방식이 있는데 바로 TDD(Test Driven Development)가 있음

- TDD는 테스트 코드를 먼저 작성핟고, 실제 컴포넌트 로직을 나중에 작성하는 것을 권장하는 개발 방법론임

#### 안티 패턴 원인 5 - 중복된 코드

- 유사하거나 동일한 UI나 비즈니스 로직 코드를 재사용 하지 않고 새로 만들어 사용한다면 여러 문제가 발생함

- 중복 코드는 코드양을 부풀릴 뿐만 아니라 버그가 발견되거나, 개선해야 할 때 해당하는 코드를 전부 수정해줘야 한다.

- 여기서 중복 배제 원칙이 중요함
  - 중복 배제 원칙 : 공통 로직을 유틸리티 함수나 고차 컴포넌트로 모아서 관리
    => 유지보수 하기 편하고, 가독성이 높은 코드가 됨

#### 안티 패턴 원인 6 - 너무 많은 기능을 가진 컴포넌트

- 앞에 설명한 내용이기도 하지만 너무 다양한 기능을 가진 컴포넌트는 이해하기도, 유지보수하기도, 테스트하기도 어려움

- 하나의 컴포넌트 안에 편지 작성, 우표 선택, 편지 전송을 모두 포함하도록 컴포넌트를 설계하면 컴포넌트를 이해하기도 힘들고, 추후 코드를 수정해야 할 때 너무 복잡할 수도 있음

- 하나의 컴포넌트 내에서 수행되는 기능들을 더 작은 단위로 컴포넌트 분리하고, 비즈니스 로직들은 커스텀 훅으로 변환하는게 유지보수, 코드 가독성에 좋다.

#### 안티패턴을 없애기 위한 접근 방식

- 고차 컴포넌트, render prop, 훅 같은 디자인 패턴 기술들 사용하기
- 인터페이스 지향 프로그래밍 하기
  - 인터페이스를 통해 소프트웨어 모듈 간에 발생하는 상호작용을 중심으로 소프트웨어를 구성하는 데 중점을 둠
  - 딱 컴포넌트를 보았을때 이건 ~을 하는 기능이구나 생각이 들 정도로 추상화를 잘 해놓는 개발하기
- 헤드리스 컴포넌트 패러다임
  - 직접적인 렌더링 역할 없이, 상태 또는 로직을 관리하는 컴포넌트 만들어서 사용하기(그냥 커스텀 훅 아니냐 이건..)
- TDD와 지속적인 리팩토링을 통해 코드 품질 높이기
  - TDD를 통해 잠재적인 문제에 대해 즉각적인 피드백 루프 생성하기
  - 리팩토링을 진행하며 기술의 본질을 파악하고, 가장 효과적인 지점을 찾아 적용하는 것이 중요
