# s 비즈니스 로직 누수 방지 및 안정적인 아키텍처 설계 가이드

프론트엔드/백엔드의 경계를 명확히 하고, 유지보수성과 확장성을 높이기 위한 설계 원칙 및 패턴들을 정리합니다.

---

## 1. 비즈니스 로직 누수(Business Logic Leakage)

### 정의

> 애플리케이션의 핵심 규칙, 계산, 절차 등이 UI나 여러 레이어에 **분산되거나 중복**되어 있는 현상.  
> 예: UI 컴포넌트 내부에서 직접 데이터 변환, 날짜 계산 등의 로직 수행

---

### 대표 징후

- UI 컴포넌트가 데이터를 직접 가공하거나 필터링
- 동일한 계산/로직이 여러 곳에 중복
- 리팩토링 시 어디를 수정해야 할지 모호함

---

### 주요 원인

| 원인                    | 설명                                      |
| ----------------------- | ----------------------------------------- |
| **단일 책임 원칙 위반** | UI가 여러 역할을 동시에 수행              |
| **과도한 의존성**       | 하나의 변경이 다른 곳까지 영향을 미침     |
| **잘못된 추상화**       | 도메인 로직이 UI나 infra에 묶여 있음      |
| **유지보수 부족**       | 기존 로직을 고려하지 않고 무분별하게 수정 |

---

### 해결 방안

- **단일 책임 원칙(SRP)**  
  → 컴포넌트는 UI에만 집중, 비즈니스 로직은 별도로 분리

- **의존성 역전 원칙(DIP)**  
  → 안정적인 추상화 레이어에만 의존 (ex. interface, adapter 등)

- **추상화 레이어 설계**  
  → 서비스 계층, 유즈케이스 계층 등 도메인 중심 분리

- **계층화 아키텍처 적용**  
  → UI / Application / Domain / Infra 구조 유지

- **디자인 패턴 도입**  
  → 전략 패턴, 템플릿 메서드 등으로 로직 관리

- **지속적인 리팩토링**  
  → 테스트 코드 기반으로 정기적인 구조 개선

---

## 2. ACL (Anti-Corruption Layer)

### 정의

> 서로 다른 시스템 간의 모델 충돌 및 형식 불일치를 방지하기 위한 **보호 계층**

---

### 목적

- 외부 API 또는 서드파티 도메인의 데이터와 **직접 연결하지 않음**
- 우리 시스템의 도메인 규칙을 **보호**
- 변화에 대한 **방어선 역할**

---

### 적용 예시

- 외부 시스템의 응답을 내부 모델로 변환하는 Mapper
- `interface Adapter`를 통해 직접 호출 방지
- 기본값 처리, 예외 핸들링 포함

---

### 주의사항: 방어적 프로그래밍

- 예외, 실패를 처리하기 위한 기본값이나 에러 처리 코드 작성
- 하지만 **과도한 if-check 남발은 오히려 가독성 저하**  
  → 핵심 로직이 흐려지지 않도록 적절히 사용

---

## 3. Prop Drilling 문제

### 정의

> 상위 컴포넌트에서 하위 컴포넌트까지 props를 **불필요하게 여러 단계** 전달하는 현상

---

### 문제점

- 컴포넌트 간 **결합도 증가**
- 중간 컴포넌트가 불필요한 props 전달 역할만 수행
- 유지보수 및 재사용 어려움

---

### 해결 방법

- **Context API** 사용
- **Zustand, Redux, Jotai** 등의 상태관리 도구 활용
- 로직/상태를 **컨테이너 컴포넌트**로 올리고 **프레젠테이셔널 컴포넌트**는 UI에만 집중

---

---

## 참고 링크

- [의존성 역전 원칙 (DIP) velog 글](https://velog.io/@harinnnnn/OOP-객체지향-5대-원칙SOLID-의존성-역전-원칙-DIP)

---
