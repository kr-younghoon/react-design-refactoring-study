# CH 1 : 리액트 안티패턴 소개

## 1.1 UI 구축의 어려움에 대한 이해

- 대부분의 애플리케이션은 복잡하고, 웹 언어가 제공하는 요소보다 더 많은 기능을 포함하고 있다.
- 따라서 HTML, CSS, JavaScript만으로는 복잡한 기능을 구현하기 어렵고, 상태 관리, 동기화, 예외 처리 등의 추가적인 고민이 필요하다.

---

## 1.2 상태 관리의 이해

- 서버 상태를 다룰 때 주의해야 할 점

  ### 1 비동기 특성

  - 데이터를 가져오는 동안 무엇을 표시할지, 오류 상황에는 어떻게 처리할지를 고민해야 함
  - 이로 인해 코드가 복잡해질 수 있음

  ### 2 오류 처리

  - API 호출 실패나 네트워크 오류 등 다양한 예외를 대비해야 함

  ### 3 로딩 상태

  - 사용자에게 로딩 중임을 알려주는 UI를 적절히 구현해야 함

  ### 4 일관성

  - 클라이언트 상태와 백엔드 데이터를 동기화할 수 있어야 함

  ### 5 캐싱

  - 서버에서 받아온 데이터를 저장해두고 재사용하는 방식
  - 하지만 다음과 같은 문제가 생길 수 있음:
    - **데이터 불일치(Stale)**: 서버와 캐시된 데이터가 서로 다른 상태가 되는 문제
    - **무효화(Invalidation)**: 더 이상 유효하지 않은 캐시 데이터를 서버에서 다시 받아와야 하는 상황

  ### 6️⃣ 업데이트 및 낙관적 UI

  - 서버 응답 전에 UI를 먼저 업데이트해 사용자 경험을 개선
  - 실패 시에는 이전 상태로 롤백이 가능해야 함

---

## 1.3 예외 흐름 탐색하기

- UI 개발 시 정상 흐름을 우선 고려하지만, 다음과 같은 예외 흐름으로 인해 UI 코드가 복잡해질 수 있음:

  1. **다른 컴포넌트에서 발생한 오류**
     - 에러를 처리하기 위해 조건문 또는 에러 바운더리 등을 추가해야 하므로, 코드 복잡도 증가
  2. **예측하지 못한 사용자 행동**
     - 입력 누락, 잘못된 입력 등 예외 상황을 고려한 UI 처리가 필요 → 코드가 복잡해짐

---

## 1.4 리액트 내 일반적인 안티패턴

- 안티패턴에 의존할수록 코드가 복잡해지고, 유지보수가 어려워짐
- 컴포넌트를 재사용 가능하고 테스트하기 쉽게 만들기 위해 **관심사 분리 원칙**을 지키는 것이 중요

### 대표적인 안티패턴

1. **Prop Drilling**

   - 데이터를 전달하기 위해 여러 중간 컴포넌트를 거쳐야 하는 구조
   - 복잡도를 높이고 유지보수성을 떨어뜨림

2. **컴포넌트 내 데이터 변환**

   - 컴포넌트의 역할이 명확하지 않아 재사용성이 낮아지고, 테스트도 어려워짐

3. **뷰 영역에서의 복잡한 로직**

   - 뷰 컴포넌트 안에서 비즈니스 로직을 다루면 관심사 분리를 방해함
   - 컴포넌트 재사용, 유지보수, 테스팅이 어려워짐

4. **테스트 부족**

   - 테스트 코드를 먼저 작성하고, 그 후 실제 로직을 구현하는 **TDD** 방식이 권장됨

5. **중복된 코드**

   - 반복되는 로직이나 구조는 유틸 함수 또는 공통 컴포넌트로 추출해야 함

6. **너무 많은 기능을 가진 컴포넌트**
   - 하나의 컴포넌트가 너무 많은 역할을 맡으면 단일 책임 원칙을 위반하게 되고, 유지보수가 어려워짐

---

### 안티패턴을 없애기 위한 접근 방식

1. **계층화된 아키텍처 & 관심사 분리**

   - 역할을 나누고 책임을 명확히 구분하여 구조적으로 관리

2. **인터페이스 지향 프로그래밍**

   - 모듈을 쉽게 교체할 수 있게 하고, 일관성을 유지

3. **헤드리스 컴포넌트**

   - UI 없이 로직만 제공받고, UI는 자유롭게 커스터마이징
   - 다양한 디자인 시스템에 적용 가능하며 재사용성이 높음

4. **TDD (Test-Driven Development)**

   - 테스트를 먼저 작성함으로써, 설계 개선 및 버그를 사전에 방지

5. **지속적인 리팩터링**
   - 기존 코드를 꾸준히 점검하고 개선하여 유지보수성과 가독성을 높임
