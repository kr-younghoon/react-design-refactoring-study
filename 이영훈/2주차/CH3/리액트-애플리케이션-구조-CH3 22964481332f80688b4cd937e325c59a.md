# 리액트-애플리케이션-구조-CH3

생성자: 영훈
생성 일시: 2025년 7월 7일 오후 4:06
카테고리: 패턴으로익히고설계로완성하는리액트
최종 편집자:: 영훈
최종 업데이트 시간: 2025년 7월 9일 오전 1:32

# 서론

> 왜 프로젝트 구조에 대해 신경 써야 하는가 ?
> 
- 잘 갖춰진 구조 → 유지보수 👍🏻
- 이해하기 쉽고 기능 확장이 쉬움

> 코드 스멜?
> 

코드가 “잘못 작동”하거나 “당장 버그가 있다”는 아님

장기적으로 유지보수, 확장성을 해치고 버그를 유발할 가능성이 높은 구조적 냄새를 말함. 마틴 파울러(Martin Fowler)가 Refactoring 에서 처음 대중화한 개념. → 당장 망가지진 않았지만, 앞으로 골칫거리가 될 신호들..

*왜 중요한지, 예시는 생략함.*

→ 구조화 전략을 잘 이해하면 성공적 프로젝트를 위한 의사 결정을 할 수 있을 것이다. 

배우는 것.

- 구조화되지 않은 프로젝트의 문제점
- 프론트엔드 애플리케이션의 복잡함에 대한 이해
- 일반적인 리액트 애플리케이션 구조
- 프로젝트 구조를 체계적으로 유지

# 3.1 구조화 되지 않은 프로젝트의 문제점

> 구조화가 덜 프로젝트의 문제점.을 다뤄보자.
> 
- 무질서한 코드 : 프로젝트가 커질수록 관련 코드를 찾는 시간과 노력을 낭비하게 된다.
- 낮은 코드 재사용성 : 적절한 구조가 없다면 재사용할 수 있는 컴포넌트를 찾는 것은 어려워진다.
- 협업의 어려움 : 서로의 코드를 이해하고 탐색하는 것이 어렵기에 의사소통, 느린 개발 속도, 버그, 코드 변경 충돌을 일으킬 위험이 있다.
- 확장성 문제 : 프로젝트가 커지고, 새 기능이 늘어날수록 다른 구성 요소를 원활하게 기존코드에 통하는 것이 어려워진다.
- 복잡한 유지보수 문제 : 명확한 구조가 없는 코드 베이스는 유지보수하기 어렵다. 코드를 구성하거나 이름 짓는 방식에 일관성이 부족하기에 문제는 점점 늘어간다.

# 3.2 프론트엔드 애플리케이션의 복잡함에 대한 이해

중간 규모의 프론트엔드 프로젝트들을 보면, 성공적 구현을 위해서 다양한 구성요소들이 필요하다. 핵심 기능 뿐만 아니라 수많은 부가적인 요소들이 프로젝트의 기능 동작을 위해 필요하다.

리액트 프로젝트의 폴더 구조는 일반적인 리액트의 코드베이스에서 관리해야 할 다양한 측면을 보여준다

- 소스 코드 : 애플리케이션의 핵심. 애플리케이션의 로직을 담고 있는 JS 또는 TS 파일, UI 구조를 위한 HTML 파일, 디자인을 표현하는 스타일 파일이 있다. 애플리케이션 동작, 사용자 인터페이스를 정의하는 모든 것은 여기에서 찾을 수 있다.
- 에셋 : 전반적인 룩 앤드 필에 기여.
    
    > look and feel 이 뭐냐
    > 
    
    제품, 서비스의 시각적, 정서적 인상을 통틀어 가리키는 디자인 용어. 컬러,폰트,레이아웃 같은 정적 요소와 모션,피드백 같은 동적 요소 모두 포함
    
- 설정 : 애플리케이션의 다양한 부분을 제어하는 중요한 매개변수를 포함. 의존성 목록을 관리하는 package.json과 프로젝트를 빌드할 때 필요한 환경변수는 애플리케이션을 운영하고 배포하는데 중요하다.
- 테스트 : 애플리케이션의 올바른 동작과 안정성을 위해 필요. 사용자 동작을 재현하고 상호작용을 검증하며 애플리케이션의 기능을 확인하는 유닛, 통합, E2E 테스트를 담고 있다. 이는 잠재적 버그를 예방하는데 도움이 된다.
- 문서 : Readme, API 문서와 코드 스타일 가이드 등 애플리케이션에 필요한 모든 정보가 문서에 있다. 프로젝트와 연관된 사람들은 문서를 통해 프로젝트를 쉽게 이해하고 코드의 일관성을 유지할 수 있습니다.
- 빌드 결과물 : 배포 가능한 최적화된 번틀 JS, CSS, HTML 그리고 디버깅에 도움이 되는 진단 파일과 임시 파일들을 포함한 빌드 실행 결과물. 애플리케이션을 최종 사용자에게 전달하는 핵심 요소이다.
- 개발 도구와 설정 파일 : 코드의 품질과 일정한 포맷을 유지하고 형상을 관리하여, 자동화된 테스팅과 배포 절차를 쉽게 해주는 도구이다. 백그라운드로 작업이 수행되며, 원활하고 오류가 없는 효율적인 개발 과정을 만들어준다.

## 각각의 기능 폴더들을 살펴보면 다양한 요소들을 확인할 수 있다

- Modal 공통 컴포넌트
- 메뉴 페이지에만 나타나는 특별한 할인 정보를 위한 SpecialOffer 또는 애플페이를 위한 PaywithApple과 같은 특정 기능을 위한 컴포넌트
- CSS-in-JS 또는 SCSS/LESS를 이용한 스타일 정의
- 단위 테스트와 브라우저 테스트 같은 다양한 테스트 코드
- 유틸리티/헬퍼 함수로 만든 계산 로직
- 재사용하는 기능들을 모은 사용자 정의 훅
- 보안, 다국어(i18n), 그 외 특별한 목적의 컨텍스트
- eslint 설정, jest 설정, webpack 설정과 같은 부가적인 설정파일

다양한 파일이 많은 상황에서 쉽고 빠르게 수정하기 위해서는 어떻게 파일을 정리해야할까. 단 하나의 방법으로 모든 요구사항을 만족할 수는 없지만, 코드베이스를 일관되게 정리하는 것이 큰 도움이 된다.

코드 요소의 이름을 짓고 구조화할 때는 일관성을 유지하는 것이 가장 중요하다. 어떤 방식을 선택하든, 프로젝트 전반에 걸쳐 일관된 방식을 유지해야한다. 

마찬가지로 `tests` 폴더에 테스트파일을 보관한다면, 이 규칙을 모든 코드베이스에 일관되게 적용해야한다. 예를 들어 테스트파일을 나타내는 __tests__나 specs처럼 다른 형식의 규칙을 사용하면 일관성을 해치고 혼란을 일으킬 수 있으므로 피해야한다.

중간 규모 이상의 프로젝트 안에 숨어있는 복잡도를 파악하고, 무질서한 코드베이스에서 작업할 떄의 어려움을 파악하였으니, 이제 코드를 구조화하기 위한 검증된 방법을 찾아보자. 이러한 전략을 통해 개발과정을 단순화하는 것이 목표이다.

# 3.3 일반적인 리액트 애플리케이션 구조

큰 규모의 리액트 애플리케이션의 구조를 만드는 방법은 여러 가지가 있다. 자주 사용되는 4가지를 알아보자.

- 기능 기반 구조
- 컴포넌트 기반 구조
- 아토믹 디자인 구조
- MVVM 구조

구조마다 각각의 장단점이 있으므로, 프로젝트마다 필요한 기능이나 복잡도를 파악하여 어떤 구조를 사용할지 결정해야 한다.

프로젝트에 필요한 특별한 기능이 있다면, 여러 개의 구조를 적절하게 섞는 방법도 있다. 어느 정도 복잡하면서도 비교적 친숙한 도메인인 온라인 쇼핑 애플리케이션 프로젝트 예제를 통해 구조별 차이를 살펴보자. 이 애플리케이션은 API 호출과 라우팅, 상태 관리 기능도 포함된다.

## 3.3.1 기능 기반 구조(Feature-based structure)

기능 기반 구조란 애플리케이션을 기능과 모듈 중심으로 구조하는 것을 의미한다. 기능 단위로 명확하게 분리하기 위해 컴포넌트와 뷰, API 호출, 상태 관리를 캡슐화하여 관리한다

![image.png](%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3-%E1%84%8B%E1%85%A2%E1%84%91%E1%85%B3%E1%86%AF%E1%84%85%E1%85%B5%E1%84%8F%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB-%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9-CH3%2022964481332f80688b4cd937e325c59a/image.png)

- features 디렉토리는 Home, Cart, ProductDetails, Checkout, Profile 등과 애플리케이션의 기능을 의미한다.
- 기능마다 `components`, `containers`, `pages`, `services`, `types` ,`utils` 폴더를 가진다.
- shared 디렉토리는 여러 기능에서 공유하여 재사용하는 components, `containers`, services, types,utils를 가진다.
- api 디렉토리는 API 호출을 하는 모듈을 가진다.
- store 디렉토리는 Redux와 같은 상태 관리를 위한 모듈을 가진다.
- store 디렉토리는 redux 와 같은 상태 관리를 위한 모듈을 가진다.
- router 디렉토리는 라우팅 설정과 관련된 컴포넌트를 가진다.
- App.tsx 파일은 앱의 시작점이다.

### 기능 기반 구조의 장점

- 명확한 관심사 분리 : 각 기능과 관련된 코드를 쉽게 찾고 수정할 수 있다.
- 모듈화 : 기능 단위로 코드가 모여 있으므로 코드 테스팅과 유지보수, 재사용이 쉽다.
- 확정성 : 새로운 기능이 추가될 떄 기존 코드에 영향을 주지 않는다.
- 팀 협업: 여러 기능을 개발자들이 동시에 작업할 때 코드 충돌을 최소화할 수 있다.

### 기능 기반 구조의 단점

- 코드 중복의 가능성 : 기능들이 비슷한 컴포넌트나 로직을 갖고 있으면 코드 중복이 발생할 수 있다. 신중하게 설계하거나 리팩토링을 통해 이를 피해야 한다.

## 3.3.2 컴포넌트 기반 구조(Component-based Structure)

컴포넌트 기반 구조는 애플리케이션을 재사용할 수 있는 컴포넌트 단위로 구조화하는 것이다. 컴포넌트는 기능 단위로 분류하고 이를 조합하여 더 큰 뷰를 만든다.

온라인 쇼핑을 컴포넌트 기반으로 구조화하면, 다음과 같은 폴더 구조를 가진다.

![image.png](%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3-%E1%84%8B%E1%85%A2%E1%84%91%E1%85%B3%E1%86%AF%E1%84%85%E1%85%B5%E1%84%8F%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB-%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9-CH3%2022964481332f80688b4cd937e325c59a/image%201.png)

### 컴포넌트 기반 구조에 대하여…

- Components: 애플리케이션의 여러 기능에서 사용하는 개별 컴포넌트를 가지게 된다. 각각의 컴포넌트는 폴더에 존재하며, 필요할 경우 자식 컴포넌트를 가진다.
- routes : 애플리케이션의 프론트엔드 라우팅을 담당한다. 라우팅 로직을 설정하는 메인 AppRouter.tsx 파일, 개별 라우팅 경로와 그에 해당하는 컴포넌트를 담은 routes.tsx 파일이 이곳에 위치한다.
- api : API 도메인이나 기능 단위의 파일을 가진다. products.ts, cart.ts, auth.ts, payment.ts 파일들은 각각의 도메인 API를 호출한다.
- 이 예제는 애플리케이션 전역 상태 관리를 위해 Redux나 Context API 와 같은 라이브러리를 사용한다고 가정한다.

### 이 구조의 장점

- 모듈화 : 컴포넌트 기반 구조는 기능 단위의 컴포넌트를 별도의 파일과 폴더에 구분하여 모듈화한다. 이로 인해 코드를 유지보수하기 쉽고 재사용성이 높아진다.
- 관심사 분리 : 컴포넌트의 개별 기능에 집중하게 되어 코드가 간결해지고 디버깅하기 쉽다. 관심사를 분리하면 유지보수하기 쉽고 가독성이 높아진다.
- 높은 코드 재사용성 : 앱의 여러 곳에서 컴포넌트를 재 사용하고 이후 또 다른 프로젝트에서도 활용하여 개발 생산성을 높일 수 있다.

### 이 구조의 단점

- 프로젝트 복잡도 증가 : 프로젝트가 커질수록 컴포넌트 폴더 구조가 복잡해지고 단순하게 유지하기 어렵다. 관리 가능한 수준을 유지하기 위해서 모범사례를 참고하여 신중하게 설계하고 계획을 세워야한다.
- 높은 진입장벽 : 컴포넌트 기반의 개발과 타입스크립트에 익숙하지 않다면 초기 학습 곡선이 가파르게 올라간다. 하지만 초기 학습에 드는 비용보다 구조화된 코드가 가져다 주는 장점이 더 많다.
- 코드 중복의 가능성 : components 폴더 안에서는 다른 컴포넌트와 동일하거나 기능이 유사한 컴포넌트를 찾기 쉽다. 컴포넌트를 더 잘게 나눌수록, 재사용할 수 있는 컴포넌트를 찾기 쉬워질 것이다. 재사용할 수 있는 컴포넌트가 점점 늘어난다면, 기능 기반 구조에서 보았던 대로 공유 폴더로 옮겨보는 것에 대해 고려해볼 수 있다.

## 3.3.3 아토믹 디자인 구조

아토믹 디자인이란? 사용자 인터페이스를 체계화하는 디자인 방법론.

사용자 인터페이스를 원자(atom)라고 부르는 재사용 가능한 작은 단위로 나누고 이를 합성하여 분자(molecules), 유기체(organisms), 템플릿(templates), 페이지(pages) 등의 큰 단위를 만들어낸다.

아토믹 디자인의 핵심 아이디어? UI 컴포넌트를 만드는 체계적인 접근 방식을 설계하여 재사용성과 확장성, 유지보수성을 높이는 것이다. 컴포넌트를 구성하고 이름을 지정하기 위해 명확한 구조를 제시함으로써 UI 코드베이스를 쉽게 이해하고 탐색할 수 있다.

- 원자 : UI를 구성하는 가장 작은 요소.
    - 버튼, 인풋, 아이콘, 레이블 등의 기본요소들이 있다. 보통 단순하여 독립된 단일 기능을 가진다.
- 분자 : 원자들을 조합하여 복잡한 UI 컴포넌트를 표현.
    - 여러 원자가 상호작용하여 기능 단위를 구성합니다. 폼 입력, 내비게이션 바 등이 있다.
- 유기체 : 더 커다란 컴포넌트이며, 분자 또는 원자들을 결합하여 기능 영역의 UI를 표현한다.
    - 헤더, 사이드바, 카드 컴포넌트 등 UI 기능 영역을 표현한다
- 템플릿 : 분자 또는 유기체들을 배치하는 레이아웃 구조
    - 페이지의 전반적인 구조나 UI의 기능 영역을 표시한다
- 페이지 : 템플릿, 유기체, 분자, 원자 등을 모두 결합한 온전한 사용자 화면 구성 전체를 의미
    - 사용자에게 전달되는 최종 결과물

![image.png](%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3-%E1%84%8B%E1%85%A2%E1%84%91%E1%85%B3%E1%86%AF%E1%84%85%E1%85%B5%E1%84%8F%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB-%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9-CH3%2022964481332f80688b4cd937e325c59a/image%202.png)

### 아토믹 디자인 구조

- `atoms`, `molecules`, `organisms`, `templates`,`pages` : 컴포넌트 합성과 추상화의 다양한 레벨을 나타낸다.
- api : API 호출과 관련된 파일을 담고 있다
- views : 컴포넌트를 렌더링하는 개별 단위의 뷰 파일이 있다.
- routes : 라우팅 설정이 있다

### 아토믹 디자인 구조의 장점

- 재사용성 : 컴포넌트를 애플리케이션 전체에서 쉽게 재사용할 수 있어 코드 효율성이 높다
- 일관성 : UI 패턴과 디자인에 대한 일관된 적용이 가능하다
- 확장성 : 모듈화된 접근 방법을 통해 컴포넌트 기능 확장이 쉽고 신규 컴포넌트를 추가하기 용이하다
- 유지보수성 : 컴포넌트가 논리적으로 구조화되어 있어 찾거나 업데이트하기 쉽다
- 쉬운 협업 : 아토믹 디자인 구조는 디자이너와 개발자가 UI 컴포넌트에 관해 논의할 때 공통 언어의 역할을 하므로 협업하기 쉽다

### 아토믹 디자인 구조의 단점

- 높은 진입장벽 : 아토믹 디자인 원칙을 효과적으로 구현하려면 초반에 학습과 적응 과정이 필요하다.
- 복잡도 : 애플리케이션이 커질수록 컴포넌트 개수가 늘어나고 그 관계가 복잡해져서 관리가 어렵다.
- 오버 엔지니어링 : 과도한 추상화는 필요 이상으로 구조를 복잡하게 만들기 때문에 컴포넌트 재사용성과 오버 엔지니어링 사이의 균형을 맞추는 것이 중요합니다.

## 3.3.4 MVVM 구조

MVVM 구조 : 주로 사용자 인터페이스를 만드는 데 사용되는 아키텍쳐 패턴

- 모델 : 실제 다루는 데이터 또는 정보를 의미
    - 데이터베이스, 파일, 웹 서비스 또는 단순한 객체 일수도 있다.
- 뷰 : 사용자가 보면서 상호작용하는 것
    - 모델을 사용자에게 보여주는 역할을 하는 것이 사용자 인터페이스
- 뷰모델 : 대부분의 로직이 위치하는 곳
    - 외부에 공개되는 속성과 명령이 있는 추상화된 뷰.
    - 뷰와 모델 사이의 차이를 메워주며, 모델의 데이터를 뷰가 쉽게 처리할 수 있느 형식으로 가공
    - 데이터에 대한 작업을 수행하고 뷰에 어떻게 보여줄지를 결정
    
    ![image.png](%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3-%E1%84%8B%E1%85%A2%E1%84%91%E1%85%B3%E1%86%AF%E1%84%85%E1%85%B5%E1%84%8F%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB-%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9-CH3%2022964481332f80688b4cd937e325c59a/image%203.png)
    

### MVVM 구조 디테일

- views: viewModel의 상태에 따라 화면에 보여주는 UI 컴포넌트
- models : 애플리케이션 도메인 객체를 나타내는 CartItemModel, ProductModel과 같은 데이터 모델 또는 엔티티가 있다
- viewmodels : 상태와 로직을 관리하고 뷰와 상호작용을 하는 훅이 있다.
- services : API 호출과 외부 서비스와의 연결을 위한 파일이 있다.
- components : 각각의 기능 단위로 재사용 가능한 UI 컴포넌트가 있다.
- routers : 라우팅 설정과 관련된 컴포넌트가 있다.
- App.tsx 파일은 애플리케이션의 진입점(entry point)이다.

### MVVM 구조의 장점

- 관심사 분리 : 뷰모델은 UI 컴포넌트에서 비즈니스 로직을 분리하여, 유지보수하기 쉽고 깔끔한 코드를 작성할 수 있다.
- 쉬운 테스팅 : 뷰모델은 실제 UI 컴포넌트 없이 쉽게 단위 테스트가 가능하다.
- 높은 재사용성 : 컴포넌트와 모델, 서비스는 다른 기능이나 뷰에서도 쉽게 재사용할 수 있다.
- 높은 확장성 : 기존에 사용하던 뷰모델에 새로운 기능이나 뷰를 쉽게 추가할 수 있다.

### MVVM 구조의 단점

- 복잡도 증가 : MVVM 패턴을 도입시 추상화 계층(abstraction layer)을 추가하게 되며, 특히 프로젝트 규모가 작다면 이로 인한 애플리케이션 복잡도가 증가한다.
- 높은 진입장벽 : MVVM 개념과 사용법에 대한 이해가 필요하다.

# 3.4 프로젝트 구조를 체계적으로 유지하기

기능 기반 구조는 프로젝트 초기에 유용한 전략이다. 프로젝트가 커지고 비슷한 패턴들이 반복되기 시작한다면, 추가 계층을 만들어 중복을 피할 수 있다.

- 온라인 쇼핑 애플리케이션 예시.

홈 , 로그인/회원가입, 스토어 주소 검색, 상품 목록, 장바구니, 주문 내역, 결제, 사용자 프로필, 쿠폰 → 이러한 페이지들이 있다.

초기 단계에서는 페이지를 기능 단위로 구성하는 것은 일반적인 접근 방식이다. 기능 별로 폴더를 만들고 관련된 컴포넌트와 스타일, 테스트 등을 넣는다.

## 3.4.1 초기 설계 구현하기

`src` 의 초기 폴더 구조는 매우 간단하며, 기능 기반 접근 방식을 따른다. + 각 페이지별 폴더가 구분된다.

![image.png](%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3-%E1%84%8B%E1%85%A2%E1%84%91%E1%85%B3%E1%86%AF%E1%84%85%E1%85%B5%E1%84%8F%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB-%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9-CH3%2022964481332f80688b4cd937e325c59a/image%204.png)

![image.png](%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3-%E1%84%8B%E1%85%A2%E1%84%91%E1%85%B3%E1%86%AF%E1%84%85%E1%85%B5%E1%84%8F%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB-%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9-CH3%2022964481332f80688b4cd937e325c59a/image%205.png)

하지만 프로젝트가 커질수록, 서로 다른 페이지에서 컴포넌트나 기능 중복이 발생한다. 이를 해결하려면 추가로 추상화 계층을 도입해야 한다.

예를 들어 Login 과 Order 페이지 모두 Button 컴포넌트가 필요하다고 페이지 별로 각각 이를 구현하는 것은 실용적이지 않다. Button 컴포넌트를 분리하여 components 나 shared 폴더와 같은 별도의 계층에 넣을 수 있다. 이렇게 하면 Button 은 재사용 가능한 코드로 중복 없이 사용할 수 있다.

## 3.4.2 중복 제거를 위한 계층 추가

이런식으로 Button을 분리하면 재사용성과 유지보수성을 높일 수 있다. 중복을 제거하고 개발 효율을 높이며 일관성이 확보된다. 프로젝트가 더 커지더라도 이런 모듈화된 접근 방식 덕분에 관리와 확장이 쉽고, 전체 코드 베이스에 영향을 주지 않으면서 신규 기능을 추가하거나 변경할 수 있다.

그러므로 다음과 같이 components 폴더에 재사용 가능한 모든 컴포넌트를 넣고, pages 폴더에 페이지와 관련된 모든 컴포넌트를 넣는다. 

![image.png](%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3-%E1%84%8B%E1%85%A2%E1%84%91%E1%85%B3%E1%86%AF%E1%84%85%E1%85%B5%E1%84%8F%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB-%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9-CH3%2022964481332f80688b4cd937e325c59a/image%206.png)

프로젝트가 커질수록, 재사용 가능한 컴포넌트를 수용할 별도의 분리된 폴더가 필요하다. 이 구조에서 각 기능의 이름을 가진 폴더 내에 구성되어 있기 떄문에 모듈성과 코드 재사용성이 높아진다.

Offer 폴더에 별도의 기능을 가진 SpecialOffer를 하위 폴더로 추가한 것처럼 컴포넌트를 계층화하여 표현할 수 있다.

components 폴더 외에도 다른 필수 구성 요소를 담을 폴더도 필요하다. 

page : 기능 중심의 페이지 컴포넌트를 담고 있ek

hooks : 재사용하는 로직과 기능을 제공하는 리액트 훅을 담고 있다.

context : 전역 상태 관리에 쓰이며, 애플리케이션에서 공유되는 다양한 컨텍스트를 담고 있다.

모든 컴포넌트를 components 폴더로 옮겨야 하는 건 아니다. 여러 페이지에서 중복되는 컴포넌트만 공유 폴더로 옮겨야 한다. 모듈성과 불필요한 복잡성 사이에서 균형을 유지해야 한다.

이 파일 구조는 프로젝트 구조가 커지더라도 더 나은 조직화, 코드 재사용, 쉬운 코드 확장을 가능하게 한다. 따라서 중복을 줄이고 애플리케이션 내의 일관성을 유지할 수 있기 때문에 관리하기 쉽다. 또한 훅과 컨텍스트를 따로 분리하기 떄문에 관련 코드를 한 곳에 모으고 전역 상태와 재사용하는 로직을 관리하기 용이하다.

## 3.4.3 파일 이름 짓기

개별 컴포넌트는 파일 이름을 정하는 몇가지 방법이 있다. 2가지 알려준다고 함

### `index.tsx` 를 사용하여 명시적 컴포넌트 이름과 파일 이름 짓기

컴포넌트 이름으로 폴더를 생성하고 각 파일은 컴포넌트를 구성하는 요소들의 명시적인 이름으로 표현한다.

![image.png](%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3-%E1%84%8B%E1%85%A2%E1%84%91%E1%85%B3%E1%86%AF%E1%84%85%E1%85%B5%E1%84%8F%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB-%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9-CH3%2022964481332f80688b4cd937e325c59a/image%207.png)

index.tsx : 외부에서 컴포넌트를 바로 임포트하여 사용할 수 있게 노출하는 익스포트 파일

Button.tsx : JSX 컴포넌트

Button.test.tsx : 컴포넌트의 테스트 파일

style.css : CSS 스타일을 정의

이 접근 방식은 파일명이 기능을 설명하여 쉽게 이해할 수 있고 각 파일의 목적이 분명하게 드러난다. 그러나 파일 탐색기, 개발 도구에서 파일을 찾을 때 긴 인덱스가 생성될 수 있다.

### 케밥 케이스로 파일 이름 짓기

***근데 도대체 뭔차이인지 명확히 모르겠다..***

## 3.4.4 사용자 설정 구조 살펴보기

# 요약

- 프로젝트 구조화의 중요성
- 프로젝트의 일반적인 구성요소
- 일반적인 구조전략
    - 기능 기반 구조
    - 컴포넌트 기반 구조
    - 아토믹 디자인 구조
    - MVVM 구조
- 프로젝트 구조의 지속적 발전