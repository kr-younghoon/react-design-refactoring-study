# ch6-일반적인-리팩터링-기법-살펴보기

생성자: 영훈
생성 일시: 2025년 7월 16일 오전 10:35
카테고리: 패턴으로익히고설계로완성하는리액트
최종 편집자:: 영훈
최종 업데이트 시간: 2025년 7월 16일 오후 8:15

# 개요

- 리팩터링
    - 특정 언어나 프레임워크를 가리지 않으며 모든 코드에 적용 가능한 개념
    - 변수 이름 바꾸기, 함수 선언 변경하기, 함수 추출하기, 필드의 이동 등 다양한 기법이 있다
    - 일회성 작업이 아니라 소규모로 반복해서 수행하면서 코드 품질과 구조를 점진적으로 발전시켜 나가는 과정
    - 튼튼하고 작업하기 쉬운 코드 베이스는 반복되는 개선작업을 통해 유지할 수 있다.

# 6.1 리팩터링 이해하기

- 리팩터링
    - 체계화된 절차와 방법에 따라 기존의 코드베이스에서 기능 동작의 외적인 변화없이 구조를 개선하는 것
    - 일상적인 코딩 작업의 기본이며, 반복적이고 점진적인 소프트웨어 개발 과정의 특성상 반드시 실천해야 한다.
    - 리팩터링 개념은 프레임워크, 패러다임에 국한되지 않고 널리 적용할 수 있다.
    - 어떤 프레임워크를 사용하든, 리팩터링은 탄탄한 코드베이스를 유지하는데 꼭 필요하다
    - 한번의 대청소를 통해 완벽한 코드베이스를 만드는 것이 아니라, 작고 점진적인 개선을 오랜 시간 지속해서 수행하는 것
        
        > 실제로 매일매일 하는 습관적 작업이어야 유지보수가 가능한 코드베이스가 된다. 반복해서 수행하다보면 어느 순간부터 초안을 작성할 때부터 리팩터링 속에서 고려하던 기준을 염두하게 된다. 그러면 자연스럽게 코드의 설계 수준이 높아지고, 결과적으로 더 읽기 쉽고 유지보수하기 좋은 코드를 쓰게 된다.
        > 
    - 각각의 변화가 코드베이스의 품질을 당장 눈에 띄게 바꾸지는 않지만, 작은 변화들이 쌓여 코드베이스의 구조와 가독성, 유지보수성에 큰 변화를 불러온다.
    - 새로운 기능을 직접 추가하는 것은 아니지만, 신규 기능들을 버그 없이 빠르게 추가하여 제공할 수 있게 하고 요구사항의 변화에 빠르고 유연하게 대처할 수 있게 한다.
    - 끊임없는 리팩터링을 통해 코드를 깔끔하고 다루기 쉽게 유지할 수 있으며, 장기적으로 지속 가능한 개발환경이 조성된다.
    - 기술스택, 플젝 규모, 범위와 상관없이 꼭 필요한 도구이다.
    - 코드베이스와 팀을 위한 장기적인 투자이자, 궁극적으로는 소프트웨어의 품질을 최대치로 끌어올리는 수단

## 6.1.1 리팩터링 중 흔히 저지르는 실수

- 흔히 저지르는 실수
    - 코드를 리팩터링하지 않고 구조를 바꿔버리는 것
        - 리팩터링과 리스트럭처링은 종종 혼용되는 용어. SW 개발에서는 의미가 다르다.

### 리팩터링

리팩터링은 체계화된 방법을 통해 코드베이스를 보다 깔끔하게 가독성을 높여 작업하기 편하게 개선하는 것이다.

외적인 부분의 수정 없이 소프트웨어의 내부 구조를 변경한다. 보통 잘게 여러 단계로 나누어 수행하며 각 리팩터링 단계에서 소프트웨어 기능은 동일하게 유지되어야 한다. 

기능을 새로 추가하는 것이 아니라, 읽기 쉽고 유지보수하기 편하며 미래의 변경에 대비할 수 있도록 하는 것이다.

- 예시
    - 커다란 컴포넌트를 다루기 쉬운 작은 컴포넌트로 쪼개기
    - 복잡한 조건 분기 로직을 전략 패턴으로 대체하는 작업

### 리스트럭처링

- 리스트럭처링은 보다 광범위하고 과감한 과정

대규모 변경을 통해 소프트웨어 내부 구조 뿐 아니라 외부 특성까지 영향을 미칠 수 있다.

소프트웨어 설계, 데이터 모델, 인터페이스 등의 변경을 포함해야할 수 도 있다. 소프트웨어의 가용성을 늘리거나 성능향상 또는 심각한 기술부채를 해결해야 하는 경우에 주로 진행한다.

- 예시
    - Redux에서 리액트 Context API 로의 이동과 같은 상태 관리 솔루션의 변경
    - 라우팅과 관련된 동작의 변경
    - 모놀리식 아키텍쳐에서 마이크로 프론트엔드 아키텍처로의 변경

### 리팩터링과 리스트럭처링

둘다 코드베이스의 품질을 높이기 위한 활동이지만 작업의 범위나 변화가 차이가 크다. 리팩터링, 리스트럭처링을 혼동하는 사람들이 더불어 하는 실수는 테스트를 자주하지 않는 것이다.

기존 코드베이스에 테스트 코드가 많지 않거나, ‘작은’ 변경에 대해서는 굳이 테스트하지 않아도 안전하다고 생각하기 때문이다.

# 6.2 리팩터링 전 테스트 추가하기

리팩터링 과정에서 기능 변화가 눈에 띄지 않아야 하므로 현재의 동작을 충분히 커버할 수 있는 테스트 코드가 있는지 확인해야 한다.

적재적소에 테스트가 없다면 위험할 뿐만 아니라, 변경된 코드에 대해 수동으로 계속 체크해야 하므로 비효율적이다.

- 예시 : TS로 작성한 온라인 쇼핑 애플리케이션

## 6.2.1 변수 이름 바꾸기

> 직관적이면서도 효과적으로 코드의 가독성과 유지보수성을 높일 수 있는 리팩터링 기술
> 

코드를 작성하는 초기 시점의 상황에 맞게 변수의 이름을 선택하더라도 코드가 진화하면서 변수의 목적이 바뀔 수 있다. 하지만 변수의 이름을 그대로 두는 경우. 이해하기 어렵고 유지보수하기 힘든 원인이 된다. 변수의 이름을 변경해 그 목적에 대해 더 정확히 설명할 수 있다면 코드의 가독성이 높아진다.

# 6.3 변수 추출하기

> 코드 가독성과 유지 보수성을 높이는 보편적 리팩터링 기법
> 
- 값을 계산하는 코드 영역을 새로운 변수로 대체하고 원래 표현식의 결괏값을 대체하는 변수에 할당하는 과정
- 코드에 복잡한 표현식이나 중복된 계산식이 있을 때 유용하다.
- 표현식 일부를 의미있는 이름의 변수로 추출하면 코드를 쉽게 이해하고 다루기 편해진다.

# 6.4 반복문을 파이프라인으로 바꾸기

> 반복문 구조를 변환 파이프라인 구조로 바꾸는 것.
> 

JS는 배열의 프로토타입 메서드로 map, filter, reduce를 지원하며 메서드 체이닝 기법으로 여러 메서드를 파이프라인의 형태로 구성할 수 있다. 각각의 메서드는 함수를 인자로 받아 이 함수를 배열의 요소에 각각  적용하여, 효과적으로 배열의 데이터 형태를 변환할 수 있다.

But! 반복문을 파이프라인으로 대체하는 것은 코드/가독성면에서 좋을 수 있지만, 특히 대용량의 데이터 세트를 다룰 때는 효과적이지 않을수있다.

따라서 대용량 데이터 세트를 반복해서 다룰땐 가독성/유지보수성/성능 요구사항을 균형있게 고려해야한다.

<aside>
❓

**선언적 코드가 덜 적절한 경우는 언제일까?**

- 로직이 복잡해져서 오히려 `reduce` 등으로 억지로 작성할 때
- 중간에 디버깅 해야할 때 : `for` 문은 각 스텝마다 `console.log` 로 쉽게 추적할 수 있음
- 반복 중 상태를 변경하거나 break/continue가 필요할 때
- 성능을 극한까지 끌어올려야 하는 대용량 반복처리
    - 중간 배열을 계속 만들기 보다는 반복문 하나로 처리하는 게 효율적일 수 있음.
</aside>

# 6.5 함수 추출하기

> 크고 복잡한 함수를 작고 다루기 쉽게 분리하여 코드의 가독성과 유지보수성을 높여주는 리팩터링 기법
> 
- 예시 : 여러 동작을 수행하는 함수를 보자
    - 데이터를 검증하고 계산을 수행한 후 결과 로깅 혹은 상태 업데이트를 하는 등의 다양한 역할을 하나의 함수가 맡으면 길고 복잡하여 이해하기 쉽지 않다.
    - 함수 추출 리팩터링은 개별적인 기능들을 식별하고 별도의 함수로 분리한 후, 원래 함수에서 새로 만든 함수를 호출하는 과정
- 장점 :
    - 코드 자체가 문서가 된다.
    - 함수 일부를 새로운 함수로 추출하고 의미를 담은 이름을 지으면, 함수의 이름 자체가 그 기능을 설명할 수 있기 때문에 코드를 이해하기 쉬워진다.
    - 또한 작게 나뉜 함수는 필요하다면 다른 곳에서 재사용할 수 있기 때문에 코드 재사용성 또한 높아진다.

# 6.6 매개변수 객체 도입

> 함수가 많은 수의 매개볍수를 가지거나, 여러개의 함수가 같은 매개변수를 공유할 때 사용하는 리팩터링 기법. 연관된 매개변수들을 하나의 객체로 묶고 이 객체를 함수에 인자로 전달한다.
> 

함수에서 수많은 매개변수는 헷갈리고 다루기 어려움

관련된 매개변수를 하나의 객체로 묶어주면 코드의 가독성이 높아지고 함수의 역할을 이해하기 쉬우며 함수 호출이 단순하고 깔끔해진다. 또한 같은 그룹의 매개변수가 여러 함수 호출에서 사용될 경우, 매개변수를 잘못된 순서로 전달할 가능성을 줄여준다.

### 예시

`calculateTotalPrice(quantity, price, discount)` 의 형태로 호출하는 함수를 매개변수 객체를 도입하여, `calculateTotalPrice({ quantity, price, discount })` 로 바꿀 수 있다. → quantity, price, discount 매개변수는 하나의 Item 객체로 묶을 수 있다.

매개변수 객체 도입은 코드에서 드러나지 않던 도메인 개념을 다시금 일깨워 주기도 한다. 매개변수 객체는 그 자체로 별도의 기능과 데이터를 다루는 하나의 클래스가 될 수 있다.

이는 좀 더 객체 지향적이고 캡슐화된 코드로 이어진다.

# 6.7 조건문 분해하기

> if-else 나 switch 와 같이 조건에 따라 분기하는 로직을 별도의 함수로 추출하는 리팩토링 기법
> 

조건문인 if 절과 else절을 별도의 함수로 나누고 각각이 지닌 기능 또는 그것이 무엇을 확하는지 나타낼 수 있도록 이름을 정해준다. 주석이 필요할 수도 있는 코드를 이름이 잘 지어진 함수로 대체하여 코드만 보고도 이해할 수 있게 하는 리팩터링 기법

# 6.8 함수 이동하기

> 함수 위치를 좀 더 적절한 곳으로 옮기는 것. 같은 클래스 안에서 이동할 수 있으며, 다른 클래스로의 이동 또는 별도의 모듈로의 이동도 가능합니다. 이 리팩토링의 목적은 기능들이 논리적으로 가장 알맞은 곳에 있게 하여, 가독성과 유지보수성을 높이고 코드를 구조화하는 것입니다.
> 

이러한 종류의 리팩터링은 클래스의 책임이 늘어나며 진화할 때 필요하다 어떤 함수는 다른 클래스에 위치하는 것이 더 알맞을 수도 있고, 클래스 내의 연관된 함수들을 묶어 별도의 클래나 모듈로 만드는 것이 나을 수도 있다.

함수 이동 리팩토링 기법은 함수를 기능의 연관성이 높거나 필요한 곳으로 옮김으로써 클래스의 복잡도를 낮출 수 있다. 이는 연관된 코드가 함께 위치하게 하여 코드 응집도를 높여준다. 또한 서로 다른 코드 간의 불필요한 상호 의존 관계를 낮출 수 있다.

# 결론

각 기법마다 결국 비슷하게 반복해서 나오는 공통된 키워드는 가독성/유지보수성/의도전달/작은단위의 책임 분리 이다. 이 점들을 고려해서 이게 진짜 개선이 되는건지. 실제 가치가 있는 리팩터링인지 계속 고려하면서 작성해나가야하지 않을까…!