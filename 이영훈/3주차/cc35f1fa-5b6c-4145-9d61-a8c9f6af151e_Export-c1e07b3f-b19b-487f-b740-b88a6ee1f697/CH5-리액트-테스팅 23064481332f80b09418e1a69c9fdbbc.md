# CH5-리액트-테스팅

생성자: 영훈
생성 일시: 2025년 7월 14일 오후 5:19
카테고리: 패턴으로익히고설계로완성하는리액트
최종 편집자:: 영훈
최종 업데이트 시간: 2025년 7월 16일 오후 8:28

# 서론

### 키워드 살펴보기

- 소프트웨어 테스팅의 중요성
- 단위 테스트
- 통합 테스트
- E2E(end-to-end) 테스트
- Cypress
- Jest
- React testing Library
- 복잡한 테스트 시나리오 다루기
- 스텁(stubbing)
- 모킹(mocking)

### CH5-리액트-테스팅의 목표

- 테스트 전략을 이해, 이를 리액트 앱으로 구현하는 것
- 애플리케이션이 버그와 회귀 테스트에 유연하게 대응하고 신규기능을 원활하게 추가할 수 있도록 테스트코드를 작성해볼 것

### 다음과 같은 주제를 다룹니다.

- 테스트가 필요한 이유
- 여러 종류의 테스트 알아보기
- Jest로 하는 개별 단위 테스팅
- 통합 테스트
- Cypress를 이용한 E2E 테스트

---

# 5.1 테스트가 필요한 이유

- 테스트는 소프트웨어의 안정성과 유지보수성을 높여주는 핵심요소이므로 선택이 아닌 필수다.
- 테스트가 없다면 소프트웨어 개발이라는 망망대해에서 나침반 없이 항해하는 것과 같다.

## 테스트의 장점

- 코드 검증
- 회귀 방지
    - 회귀(regression) : 애플리케이션을 확장하면서 새로운 코드의 추가로 인해 기존에 잘 작동하던 기능을 깨뜨릴 수 있다.
- 리팩터링과 유지보수의 용이함
- 코드 품질에 대한 신뢰 향상
- 문서화
    
    <aside>
    ❓
    
    **→ 문서로 어떻게/왜 쓰는가?**
    
    1. BDD 스타일로 작성하면 자연어처럼 읽히는 명세서가 된다
    2. 기존 문서보다 항상 최신 상태를 유지한다.
    3. 새로운 개발자가 코드를 빠르게 이해할 수 있따.
        1. 테스트를 보면 기능의 의도/사용법/예외상황등을 명확히 파악할 수 있음
        2. 이 함수가 궁금하면 테스트 폴더에서 찾아보면 나옴 
    </aside>
    

# 5.2 여러 종류의 테스트

- 단위 테스트 : 개발 컴포넌트나 함수의 기능을 격리하여 각각 예상대로 동작하는지 확인
- 통합 테스트 : 다른 모듈과 서비스들이 원활하게 상호작용하여 함께 잘 동작하는지 검사
- E2E 테스트 : 전체 애플리케이션의 흐름을 시작부터 종료까지 실제 사용자 행동을 묘사하여 테스트

### 프로젝트에서 테스트를 구성하는 방법

- 빠르게 수행이 가능한 단위 테스트는 많은 시나리오를 만들고 자주 실행하여 상세한 피드백을 확인해야 한다.
- 수행 시간이 많이 걸리는 E2E 테스트는 단위 테스트보다는 시나리오 수는 적지만, 각 기능들이 유기적으로 동작하는지를 검증해야 한다.

→ 이러한 접근 방식은 테스트 피라미드 방법론과 일치한다.

![image.png](CH5-%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3-%E1%84%90%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B5%E1%86%BC%2023064481332f80b09418e1a69c9fdbbc/image.png)

### 테스트 미라미드 방법론

- 마이크 콘(Mike Cohn)이 고안한 테스트 피라미드는 통합/E2E 테스트 보다 단위 테스트를 더 많이 수행할 것
    - 단위 테스트는 빠르고 단순하며 유지하기 쉽다
- 이 모델은 진화하고 있다. FE에서 앱의 복잡도는 높아지고 상호작용이 많아지며, 통합,E2E가 중요해졌다.
    - Cypress, Puppeteer와 같은 도구로 브라우저의 사용자 행동을 모방하는 E2E 테스트를 쉽게 작성 가능하다
    - 리액트 테스팅 라이브러리는 컴포넌트 간의 상호작용을 쉽게 확인할 수 있도록 통합테스트를 더욱 원활하게 해준다.

### 새로운 테스트는 계속 등장한다

- 테스팅 방법론 : 시각적 회귀 테스트
    - 웹 애플리케이션의 시각적으로 나타나는 부분을 저장하고 이전 버전과 비교하는 방식
    - 사용자 인터페이스의 의도하지 않은 시각적 오류와 변경 사항이 개발 도중 발생했을 때, 이러한 유형의 테스트가 특히 유용하다.
    - 각기 다른 시점에서 웹페이지 또는 컴포넌트의 스크린샷, 스냅샷을 찍어 픽셀 단위로 비교하며 시각적 차이점을 찾아낸다. 발견된 경우 리뷰가 필요하다고 말해줌
    - 감지된 변화가 예상된 것인지, 아니면 의도치 않은 변화라 수정이 필요한지 리뷰를 진행할 때 결정한다.
- 테스팅 방법론 : 정적검사(static checks)
    - 오류를 잡아내고 코딩 표준을 보장하기 위해 코드를 실행시키지 않고 구문 분석을 하는 것
    - 구문 오류를 체크, 린팅을 통한 코드 표준을 강제하고, 타입 검사를 통해 올바른 데이터 타입을 확인
    - 코드의 복잡도를 분석하고 의존성을 검사하며 보안 취약점을 확인

### 테스트 피라미드의 결론.

- 요구사항에 따라 피라미드의 구체적인 모양은 다를 수 있다.
- 중요한점은 애플리케이션 다양한 영역에서 빠르고 유용한 피드백을 제공할 수 있는 균형 잡힌 테스트 전략을 갖추는 것.

# 5.3 Jest로 하는 개별 단위 테스팅

- 단위테스트
    - 가장 작은 단위, 테스트 피라미드의 기본 토대
    - 함수, 메서드 또는 컴포넌트와 같은 기본 단위 코드가 격리된 환경에서 예상한 대로 동작을 수행하는지 검증한다.
    - 작성하고 실행하기 쉬우며 개발자에게 즉각적인 피드백을 제공한다.

### Jest를 이용한 단위/통합 테스트

- Jest는 페이스북이 만든 범용 자바스크립트 테스팅 프레임워크, 단순함에 초점이 맞춰져있음
- 비동기 테스트, 모킹, 스냅샷 테스팅 등을 지원, 기능이 풍부하여 리액트 애플리케이션을 테스트하기 좋은 선택

## 테스트 작성하기

### **1. 테스트 대상 함수 (math.ts)**

```tsx
// math.ts 파일
export function add(a: number, b: number) {
  return a + b;
}
```

### **2. 첫 테스트 작성 (math.test.ts)**

`add` 함수를 테스트하기 위해 `math.ts` 파일과 **같은 디렉터리에** `math.test.ts` 파일을 생성합니다. 

이 파일에 다음 코드를 작성하여 첫 테스트를 수행할 수 있습니다.

```tsx
// math.test.ts 파일 (첫 테스트)
import { add } from './math'; // math.ts에서 add 함수를 가져옵니다.

test('add adds numbers correctly', () => { // 'test' 함수는 테스트의 설명과 실제 테스트 로직을 포함합니다.
  expect(add(1, 2)).toBe(3); // 'expect'는 실제 값을, 'toBe'는 예상 값과 비교하는 매처입니다.
});
```

- **test 함수**: 테스트를 정의하는 데 사용되며, 테스트의 문자열 설명과 테스트 로직을 담은 콜백 함수를 인수로 받습니다.
- **expect**: Jest 함수로, 실제 값을 인수로 받습니다.
- **toBe**: 매처(matcher) 함수로, `expect`로 전달된 실제 값(`add(1, 2)`)이 예상 값(`3`)과 같은지 비교합니다.

### **3. test와 it의 사용 (선택 사항)**

Jest에서 `test`와 `it`는 **동일한 함수이며 상호 교환적으로 사용될 수 있습니다**. 이 책에서는 행동 주도 개발(BDD) 스타일을 따라 `it`을 사용하여 테스트를 작성한다고 언급되어 있습니다. `it`을 사용하면 테스트 설명이 "it adds 1 + 2 to equal 3"처럼 문장처럼 읽히도록 하여, 특히 비개발자에게 테스트가 무엇을 검증하려는지 더 명확하게 전달할 수 있습니다.

```tsx
// math.test.ts 파일 (it 함수 사용 예시)
import { add } from './math';

it('add adds numbers correctly', () => { // 'test' 대신 'it'을 사용하여 테스트를 정의합니다.
  expect(add(1, 2)).toBe(3);
});
```

## 테스트 그룹 묶기

### **4. 테스트 그룹화 (describe 사용)**

관련된 테스트들을 하나의 블록으로 그룹화하면 테스트 파일의 가독성이 크게 향상됩니다. Jest에서는 `describe` 함수를 사용하여 관련된 테스트들을 하나의 단위로 그룹화할 수 있습니다.

```tsx
// math.test.ts 파일 (describe를 이용한 그룹화)
import { add } from './math';

describe('math functions', () => { // 'math functions'에 관련된 테스트들을 그룹화합니다.
  it('adds positive numbers correctly', () => {
    expect(add(1, 2)).toBe(3);
  });

  it('adds negative numbers correctly', () => {
    expect(add(-1, -2)).toBe(-3);
  });

  // 필요하다면 더 많은 테스트를 추가할 수 있습니다.
});
```

- **describe 함수**: 관련된 테스트들을 묶어주는 역할을 합니다. 이 예시에서는 `math functions`에 대한 테스트들을 묶습니다.
- 이 `describe` 블록 안에는 `it` 함수를 사용하여 각각의 개별 테스트 케이스를 정의합니다.

### **5. 테스트 그룹 중첩 (describe 중첩)**

Jest에서는 `describe` 블록을 **중첩**하여 테스트를 더욱 체계적으로 구성할 수 있습니다. 예를 들어, 계산기 기능에 덧셈, 뺄셈, 곱셈, 나눗셈이 포함된다면 다음과 같이 구조화할 수 있습니다.

```tsx
// math.test.ts 파일 (describe 중첩 예시)
import { add } from './math'; // add 함수는 계속 사용한다고 가정

describe('calculator', () => { // 최상위 'calculator' 그룹
  describe('addition', () => { // 'addition'에 관련된 테스트 그룹
    it('adds positive numbers correctly', () => {
        expect(add(1, 2)).toBe(3);
    });

    it('adds negative numbers correctly', () => {
        expect(add(-1, -2)).toBe(-3);
    });
    // 덧셈에 대한 더 많은 테스트...
  });

  describe('subtraction', () => { // 'subtraction'에 관련된 테스트 그룹
    it('subtracts positive numbers', () => {
      // 여기에 뺄셈 테스트 로직
      // expect(subtract(5, 3)).toBe(2);
    });
    // 뺄셈에 대한 더 많은 테스트...
  });

  // 곱셈 및 나눗셈에 대한 다른 describe 블록들도 추가할 수 있습니다.
});
```

이 중첩 구조는 테스트 스위트를 더 **조직적이고, 읽기 쉬우며, 탐색하기 쉽게** 만들어 줍니다.

## BDD? 행동 주도 개발, Behavior-Driven-Development

- 소프트웨어 프로젝트에서 개발자, QA, 비기술적인 참여자들 간의 협업을 강조하는 소프트웨어 개발 접근 방식(이라고 책에서 표현)
- 테스트 주도 개발(TDD)에서 파생된 개발 방법론으로 사용자 또는 비즈니스 요구사항을 자연어로 표현하여 개발과 테스트를 진행하는 방법
- 개발자 뿐만 아니라 모든 이해 관계자가 기능과 동작을 명확히 이해하고, 그 이해를 코드로 변환하는데 중점을 둔다.

### 핵심!

- 개발이 시작되기 전 원하는 행동에 대한 명확한 이해를 바탕으로 진행 → 개발이 비즈니스 요구사항과 일치하도록한다.
- 
    - Given-When-Then 구조를 따르는 문법으로 시나리오를 작성할 때 자주 사용된다.
        - Given(주어진 상황): 초기 상태나 전제 조건을 기술합니다.
        - When(행동) : 수행할 동작이나 이벤트를 기술합니다.
        - Then(결과) : 예상되는 결과나 상태를 기술합니다.
    - 예시
    
    ```tsx
    Feature: 계산기 기능
    
    	Scenario: 두 수를 더한다
    		Given 계산기에 2와 3을 입력하고
    		When 더하기를 수행하면
    		Then 결과는 5가 되어야 한다
    ```
    

![image.png](CH5-%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3-%E1%84%90%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B5%E1%86%BC%2023064481332f80b09418e1a69c9fdbbc/image%201.png)

- 모든 이해관계자들이 읽고 이해 할 수 있는 명확하고 서술적인 언어를 사용
    - ex: Jest의 it함수
- 개발을 안내하고 인수 기준 역할을 하는 실행가능한 명세를 활용한다.
- 오해를 줄이는 것을 목표. 개발된 소프트웨어가 비즈니스 요구사항을 진정으로 충족하도록 보장하는데 기역한다.

## 5.3.3 리액트 컴포넌트 테스트

- Jest만 사용하면 RTL(리액트 테스팅 라이브러리)와 같은 전용 라이브러리를 사용하는 것보다 코드가 번잡해질 수 있다.
- 리액트 테스팅 라이브러리 :
    - 리액트 컴포넌트 테스팅을 위한 강력한 경량 라이브러리
    - Jest를 기반으로 리액트 컴포넌트를 손쉽게 다루는 유틸리티 함수들이 추가된 라이브러리
    - 테스트 코드를 사용자의 소프트웨어 사용 형태와 유사하게 작성해야함
    - 사용자 처럼 애플리케이션과 상호작용을 하며, 세부 구현에 대한 것이 아닌 기능에 대한 테스트를 하는 것

### 예제

**1. 테스트 대상 컴포넌트 (Section.tsx)**

먼저 테스트할 간단한 React 컴포넌트인 `Section.tsx` 파일입니다:

```tsx
// Section.tsx 파일
type SectionProps = {
  heading: string;
  content: string;
};

const Section = ({ heading, content }: SectionProps) => {
  return (
    <article>
      <h1>{heading}</h1>
      <p>{content}</p>
    </article>
  );
};

export { Section };
```

이 컴포넌트는 `heading`과 `content` 두 개의 props를 받아 `article` 태그 안에 렌더링하는 표현(presentational) 컴포넌트입니다.

**2. 테스트 파일 작성 (Section.test.tsx)**

`Section` 컴포넌트를 테스트하기 위해 `Section.tsx` 파일 옆에 `Section.test.tsx`라는 새 파일을 생성합니다. 여기에 테스트 코드를 작성합니다.

```tsx
// Section.test.tsx 파일
import React from "react";
import { render, screen } from "@testing-library/react"; // @testing-library/react에서 render와 screen을 가져옵니다.
import { Section } from "../component/Section"; // Section 컴포넌트를 가져옵니다.

describe("Section", () => { // "Section"이라는 이름으로 관련된 테스트들을 그룹화합니다.
  it("renders a section with heading and content", () => { // 테스트 케이스를 정의합니다.
    render(<Section heading="Basic" content="Hello world" />); // Section 컴포넌트를 렌더링합니다.

    // heading과 content가 문서에 존재하는지 확인하는 검증입니다.
    expect(screen.getByText("Basic")).toBeInTheDocument(); // "Basic" 텍스트를 가진 요소가 DOM에 있는지 확인합니다.
    expect(screen.getByText("Hello world")).toBeInTheDocument(); // "Hello world" 텍스트를 가진 요소가 DOM에 있는지 확인합니다.
  });
});
```

**3. 테스트 코드 설명**

이 테스트 코드는 `@testing-library/react`를 사용하여 `Section` 컴포넌트가 예상대로 작동하는지 확인합니다.

- **describe("Section", () => { ... });**: 이 코드는 `Section` 컴포넌트와 관련된 모든 테스트를 그룹화하는 테스트 스위트(test suite)를 정의합니다.
- **it("renders a section with heading and content", () => { ... });**: 이 함수는 특정 테스트 케이스를 나타내며, 테스트가 무엇을 검증하려는지 문장처럼 읽히도록 돕는 BDD(행동 주도 개발) 스타일을 따릅니다.
- **render(<Section heading="Basic" content="Hello world" />);**: `@testing-library/react`에서 제공하는 `render` 함수는 `Section` 컴포넌트를 특정 props(`heading`은 "Basic", `content`는 "Hello world")와 함께 렌더링하는 데 사용됩니다.
- **screen.getByText("Basic")**: `screen.getByText` 함수는 DOM (렌더링된 `Section` 컴포넌트의 출력)에서 특정 텍스트를 포함하는 요소를 쿼리하는 데 사용됩니다.
- **expect(...).toBeInTheDocument();**: `expect`와 `toBeInTheDocument` 매처(matcher)는 이러한 요소들의 상태에 대한 어설션(assertion)을 만듭니다. 이 테스트는 "Basic" 텍스트를 가진 요소와 "Hello world" 텍스트를 가진 요소가 DOM에 존재해야 한다고 단언하며, 이는 `Section` 컴포넌트가 `heading` 및 `content` props를 올바르게 렌더링했음을 나타냅니다.

이러한 방식은 React 컴포넌트에 대한 간단한 유닛 테스트의 시작점을 제공합니다. 

그러나 복잡한 실제 프로젝트에서는 여러 컴포넌트가 조화롭게 상호작용해야 하는 시나리오가 자주 발생하며, 이때는 통합 테스트(integration tests)와 같은 더 포괄적인 테스트 전략을 사용해야 합니다.

# 5.4 통합 테스트

- 테스트 피라미드에서 단위 테스트 위에 있는 통합 테스트는 여러 단위 코드들 사이의 상호작용에 대해 검증한다.
    - 상호작용 ? 컴포넌트 간의 상호 작용 또는 서버와 클라이언트 사이의 상호작용
    - 통합 테스트의 목적
        - 각기 다른 부분들을 통합하면서 생길 수 있는 문제를 발견하는 것
- 예제 ⇒ 리액트 컴포넌트의 통합 테스트 예제
    - 체크 박스와 [Next] 버튼을 각각 테스트하지 않고 두 버튼 간의 상호작용에 대해 검증하는 것
    - (예제에 대한 부분은 생략)
    - 중요한 것은 개별 리액트 컴포넌트에 대한 단위 테스트를 수행하는 것이 아니라, DOM 요소 간의 상호 작용에 초점을 맞추는 것
    - 통합 테스트에서 모든 기능을 지원하는 브라우저를 사용하지 않고, 메모리 위에서 동작하는 헤드리스 브라우저인 `jsdom` 을 사용한다.
    - 제한된 환경에서 수행하는 통합테스트일지라도, 클릭 이벤트와 버튼 활성화가 예상대로 동작하는지를 확인하는데는 충분하다.
- jsdom
    
    자바스크립트 기반의 헤드리스 브라우저. 실제 웹 브라우저와 유사한 테스팅 환경을 만들때 사용한다. 자바스크립트로 HTML, DOM, CSS 와 같은 웹 표준을 구현한다.
    
    테스트 프레임워크에서는 DOM을 기본적으로 제공하지 않는다. → jsdom이 필요하다!
    
    jsdom 왜 필요 ? → 프레임워크를 사용할 때 JS는 DOM과 직접 상호 작용한다. 테스트가 유효하기 위해서 이러한 상호작용을 묘사할 수 있어야 한다. jsdom은 브라우저를 띄우지 않게 이를 가능하게 한다.
    
- 통합테스트에서는 여러 다양한 모듈 사이의 상호작용에 집중한다.
    - 하지만 상호작용이 기대한 대로 동작한다 하더라도 더 큰 범위의 시스템이 제대로 동작하지 않을 수도..!
    - 사용자의 동작은 종종 여러 단계를 거치는 복잡한 흐름이 되기도 하므로, 소프트웨어의 안정적인 동작을 보장하기 위해 각 단계들을 매끄럽게 연결하는 과정이 중요하다!

# 5.5 Cypress를 이용한 E2E 테스트

- E2E 테스트
    - 테스트 피라미드의 가장 상위층
    - 실제 사용자 흐름과 상호작용을 묘사하여, 시스템 전체를 테스트
    - 사용자 인터페이스부터 백엔드 시스템 까지 애플리케이션의 모든 부분이 잘 동작하는지 검증
    - 이 책에서는 Cypress E2E 테스트 프레임워크를 사용할 예정.
- Cypress
    - 모던 웹 애플리케이션에서 E2E 테스팅을 하는 유용한 도구
    - 많은 테스팅 시스템에서 일반적으로 사용하는 셀레늄과 달리, 실제 브라우저에서 동작하므로 안정적으로 테스트할 수 있고 더 나은 디버깅 경험을 제공

## 5.5.1 Cypress 설치

- **`cypress` 디렉토리**: 이 디렉토리는 모든 Cypress 관련 파일의 **루트 디렉토리**입니다.
    - **`downloads` 디렉토리**: 이 디렉토리는 일반적으로 Cypress 테스트 중에 다운로드된 파일이 저장되는 곳입니다. 소스에서는 이 챕터에서 이 디렉토리를 사용하지 않는다고 언급합니다.
    - **`e2e` 디렉토리**: 이 디렉토리는 **E2E(End-to-End) 테스트 파일**이 위치하는 곳입니다. 예를 들어, `quote-of-the-day.spec.cy.js`와 같은 파일이 여기에 생성됩니다.
    - **`fixtures` 디렉토리**: 테스트에서 사용할 수 있는 **외부 정적 데이터를 배치**하는 곳입니다. 예를 들어, 네트워크 응답을 목(mocking)하기 위한 JSON 데이터를 여기에 둘 수 있습니다.
    - **`support` 디렉토리**: 이 디렉토리에는 Cypress 명령어 및 지원 파일이 저장됩니다. 소스에서는 이 디렉토리에 대해서도 자세히 다루지 않습니다.

## 5.5.2 첫 E2E 테스트 실행하기

- `quote-of-the-day.spec.cy.js` 파일을 수정해서 원격 웹 사이트에 접근
    - 생략

## 5.5.3 네트워크 요청 가로채기

- 몇몇 상황의 경우 UI 동작을 위해 실제 네트워크 요청을 보내고 싶지 않을도 있다.
- 또는 네트워크 응답에 직접 의존하는 것이 실용적이지 못한 경우도 있다.
- 예시
    - 명언이 무작위로 생성되기에 우리는 네트워크 요청을 보내기 전에는 어떤 명언이 표시될지 예측할 수 없다.
    - 테스트를 위해서 우리는 네트워크 요청을 보내면서도 응답을 고정시킬 방법이 필요하다.
    - `Cypress/cy.intercept API` : 엔드포인트로 보내는 네트워크 요청을 가로채서 고정된 데이터를 반환하는 방법
        - 이것을 통해서 E2E 테스트를 진행하는 예시(생략)
- 흥미로운 부분
    - cy.intercept함수로 HTTP 요청을 대신하면 E2E 테스트의 정의에서 벗어나게 된다.
    - 백엔드 응답을 모킹응답으로 제어하는 것은 완전한 E2E 흐름이라고 보기 어렵다.
    - 이 접근 방식이 나쁜 것은 아니다
    - 복잡한 시스템을 테스트할 때 시스템의 각 영역을 격리시키면 테스트하는 부분에 대해 충분히 제어할 수 있고 예측 가능하며 안정적인 테스트가 가능하다