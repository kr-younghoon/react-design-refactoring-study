# ch-1-리액트-안티패턴-소개

생성자: 영훈
생성 일시: 2025년 6월 28일 오후 12:15
카테고리: 패턴으로익히고설계로완성하는리액트
최종 편집자:: 영훈
최종 업데이트 시간: 2025년 7월 2일 오전 2:17

# 서론 👀

안티패턴은 명백한 기술적 오류는 아니기에 처음 코드는 문제없이 올바르게 동작한다.
하지만 코드의 기능이 늘어날수록 안티패턴은 문제를 일으킨다.

_→ 코드의 기능이라는 것은 어떤 단위에서 이야기 되는 것일까?_

이 책에서는 오류로 이어지기 쉬운 여러가지 잘못 작성된 예제 코드들을 살펴볼 예정.
어떤 코드들은 마치 암호처럼 해독하기 어려울 수도 있고, 수정하거나 기능을 확장하기 까다로운 경우도 있다.

단순한 기능을 수행하기에 충분한 코드라도, 그 역할이 늘어날 수록 불안정해지기도 한다.
이와 같은 불완전한 코드에 오랜 시간 검증된 패턴과 원칙을 자연스럽게 담아낼 것이다.

_→ 우리의 목표는 불완전한 코드에 오랜 시간 검증된 패턴과 원칙을 적용하는 것 아닐까?_

이 책은 실용성을 강조한다.(생략) 몰입할 수 있도록 구성했다.

이번 장에서는 복잡한 상태 관리와 비동기 작업이 코드의 가독성을 얼마나 저해하는지 보여주며, 고급 리액트 앱 개발에서 발생하는 복잡한 문제를 다룬다.

- UI 구축의 어려움에 대한 이해
- 상태 관리의 이해
- 예외 흐름 살펴보기
- 리액트의 일반적인 안티패턴 살펴보기

# 1.1 UI 구축의 어려움에 대한 이해

1.1장에서는 HTML만으로는 다양한 동적 웹페이지를 구현할 수 없음을 설명하는 듯하다.

_→ 웹 UI 개발의 언어 불일치 문제를 안태패턴 중 하나라고 할 수 있는가 ? 아니다. 그로 인해 발생하는 문제이다?_

- 대부분의 현대 앱은 웹 브라우저에서 제공하는 내장 언어로는 복잡한 UI 요소를 구축하기 불충분하다. 예를 들어 단순한 문서 형태의 웹 페이지가 아니라면, HTML 과 같은 언어만으로는 한계가 있습니다.
- 현대 웹 UI는 티켓 예매 플랫폼, 프로젝트 관리 도구 , 이미지 갤러리 처럼 매우 복잡하며, 기본 웹 언어는 이를 제대로 지원하지 않는다.
- 따라서 개발자들은 아코디언, 데이터 탐색 컴포넌트, 드롭다운 목록과 같은 UI 구성 요소를 시뮬레이션하기 위해 추가적인 노력을 기울여야 한다. 근본적으로는 여전히 문서를 다루는 것이지, 진정한 UI 구성 요소를 다루는 것은 아니다.
- 이상적인 UI 구축은 Figma 또는 C++ Builder, Delphi와 같이 시각적 UI 툴을 사용하여 마음대로 옮겨서 하면 좋겠지만 웹 개발은 그렇지 않다. 예를 들어, 검색 인풋창을 만들려면 여러 요소를 감싸고, 색상을 미세 조정하고, 패딩과 글꼴을 조정하며, 사용자 안내를 위한 아이콘을 추가해야 한다.

_→ 1.1장에서는 언어 불일치, UI 개발의 복잡성으로 인한 패턴 도입의 필요성을 제기하고 있는 것 같다. 번역의 실수인지 엄청 공감이 되거나 하지는 않는다._

# 1.2 상태 관리의 이해

1.2장에서는 FE 개발에서 상태 관리가 얼마나 복잡한지 이야기한다.서버에서 오는 데이터들(책에서는 상태 라고 표현함)을 FE에서 주의하여 다루어야 한다고 이야기한다.

## 원격 상태의 복잡성

- **비동기적 특성**: 원격 데이터 페칭은 비동기적 작업이므로, 특히 여러 원격 데이터를 동기화해야 할 때 타이밍과 관련하여 복잡성을 더합니다
- **오류 처리**: 원격 연결 실패나 서버 오류가 발생할 수 있으며, 사용자 경험을 원활하게 하기 위해 이러한 시나리오를 적절히 관리하는 것이 어렵습니다
- **로딩 상태**: 데이터가 도착하기를 기다리는 동안 "로딩" 상태를 효과적으로 처리해야 하며, 이는 로딩 인디케이터나 대체 UI를 보여주는 것을 포함합니다
- **일관성**: 특히 실시간 애플리케이션이나 여러 사용자가 동일한 데이터를 변경하는 경우, 프론트엔드 상태를 백엔드와 동기화된 상태로 유지하는 것이 어렵습니다
- **캐싱**: 일부 원격 상태를 로컬에 저장하면 성능이 향상되지만, 데이터 무효화 및 부실함과 같은 자체적인 문제를 야기합니다
- **업데이트 및 낙관적 UI(Optimistic UI)**: 사용자가 변경을 가했을 때 서버 호출이 성공할 것이라고 가정하고 UI를 낙관적으로 업데이트할 수 있지만, 실패할 경우 프론트엔드 상태의 변경 사항을 롤백할 방법이 필요합니다

이후애 원격 데이터를 렌더링하는 코드는 정적 데이터 렌더링 코드보다 더 많은 코드가 필요하다고 한다. 이상적인 시나리오 외에도 비동기 호출에 대응하는 처리 시나리오가 고려되는 등 코드를 더 길고 어렵게 만든다고 설명한다. 로컬 상태 관리 문제도 이야기하는 등 결국 코드의 복잡성을 이야기하고 있다.

# 1.3 예외 흐름 탐색하기

1.3장에서는 예외 흐름을 이해하고 관리하는 것에 대한 중요성에 대해 이야기한다.

### 1.3.1 다른 컴포넌트에서 발생한 오류

App 내에서 타사 컴포넌트나 다른 팀의 컴포넌트를 사용할 때, 해당 컴포넌트가 오류를 발생시키면 UI가 중단되거나 예상치 못한 동작을 일으킬 수 있다. 이러한 오류를 우리는 우아하게 처리하기 위해 조건부 로직이나 오류 경계를 추가하며 이것은 UI를 복잡하게 만든다. 이것을 대비하여 예외처리 UI(fallbacks, loading indicator, error message 등)를 고려해야한다.

### 1.3.2 예측하지 못한 사용자 행동

UI를 아무리 완벽하게 설계하더라도 사용자는 항상 예상치 못한 방식으로 시스템을 사용할 수 있다. 우리는 이것을 위해 edge cases를 처리하기 위해 추가적인 유효성 검사, 검사 및 안전 장치를 구현해야 하며, 이는 UI 코드베이스를 복잡하게 만들 수 있다.

### 대맥락적인 중요성 :

여러가지 예제와 컨텍스트를 통해 React로 애플리케이션을 구축하는데에는 어떤 어려움이 있는지를 보았을 것이다. 리액트는 명확한 문제해결을 위한 가이드를 주지 않는다. 자칫하다가는 장기적으로 안티패턴으로 가득 찬 솔루션을 만들게 되는 경우가 많다.

# 1.4 리액트의 일반적인 안티패턴 살펴보기

1.4장에서는 흔히 접하는 안티패턴의 개념 소개와 React App에서 자주 발생하는 실제적 안티패턴들을 구체적인 예시와 함께 설명한다. 안티패턴은 얼핏 보기에는 문제를 해결하는 유익한 솔루션처럼 보일 수 있지만, 시간이 지남에 따라 복잡성, 비효율성을 야기할 수 있는 숨겨진 문제점을 가지고 있다.

## 1.4.1 Prop Drilling

복잡한 앱에서 상태를 관리하고 모든 컴포넌트가 필요한 데이터에 접근하도록 보장하는 것은 어려울 수 있다. Props drilling은 필요한 데이터(prop)가 실제로 해당 데이터를 필요로 하는 자식 컴포넌트에 도달하기 위해 여러 중간 컴포넌트를 통해 전달되는 현상이다. 이러한 접근 방식은 복잡성을 증가시키며, 유지보수성을 저하시킨다. 여러 Props가 다양한 컴포넌트를 통해 전달될 때 데이터 흐름을 이해하고 디버깅하는 것이 어려워집니다.

잠재적인 해결책은 Context API를 활용하는 것이다. ContextAPI는 컴포넌트 트리 내의 모든 레벨을 통해 명시적으로 Props를 전달할 필요없이 컴포넌트 간에 값을 공유하는 방법을 제공한다.

## 1.4.2 컴포넌트 내 데이터 변환

개발자들이 복잡한 데이터 변환 로직을 컴포넌트 내에 직접 도입하는 흔한 실수가 있다. 외부 API나 백엔드로부터 데이터를 받으면 프론트엔드에 적합하지 않은 형태나 형식으로 제공되는 경우가 많다. 이를 더 높은 수준에서 또는 util 함수에서 조장하는 대신, 변환이 컴포넌트 내에서 정의되는 경우가 있다.

예시 ) UserProfile 컴포넌트가 fetching해온 사용자 데이터를 직접 컴포넌트 내부에서 firstName, lastName,addressLine1, city, country 등을 조합하여 name이나 address와 같은 새로운 형태로 변환하는 것이다. → 이러한 접근 방식은 명확성 부족, 재사용성 감소, 테스트의 어려움과 같은 문제를 야기한다.

## 1.4.3 뷰 영역의 복잡한 로직

리액트와 같은 최신 프론트엔드 프레임워크의 핵심은 관심사의 명확한 분리이다. 컴포넌트는 비즈니스 로직의 복잡성을 알지 못하고 프레젠테이션에 집중해야한다. 그러나 뷰 컴포넌트 내에서 비즈니스 로직을 주입하는 것은 흔한 함정이다. 이는 깨끗한 관심사 분리를 방해할 뿐만 아니라 컴포넌트를 비대하게 만들고 테스트, 재사용을 어렵게 만든다.

이러한 접근 방식은 재사용성, 테스트, 유지보수성 측면에서 문제가 된다. 컴포넌트가 재사용 가능하고 유지보수가 용이하도록 관심사 분리 원칙을 따르는 것이 중요하다. 이는 비즈니스 로직을 프레젠테이션 계층으로부터 분리하고 계층화된 아키텍쳐를 채택함으로써 달성할 수 있으며, 코드의 각 부분이 자체적 특정 책임을 처리하도록 하여 더 모듈화되고 유지보수 가능한 코드베이스로 이어지도록 한다.

## 1.4.4 테스트 부족

테스트 없이 쇼핑 카트와 같은 중요한 컴포넌트를 구축하면 부정확한 가격 책정, 아이템 추가/제거 오류, 심지어 보안 취약성과 같은 문제가 발생할 수 있다. 데이터가 여러번 잘못 추가되거나, 가격이 동적으로 변경되거나, 할인이 적용되는 등의 시나리오를 처리하지 못할 수 있다.

TDD를 강조한다. TDD는 오류를 일찍 발견하는 것 이상으로, 잘 구조화되고 유지보수 가능한 코드를 만든다. 애플리케이션이 커지더라도 TDD 테스트코드가 있다면 구현 코드 수정이나 기능 추가에도 정확성을 보장할 수 있다.

## 1.4.5 중복 코드

동일하거나 매우 유사한 코드 덩어리가 애플리케이션의 여러 부분에 흩어져 있는 것은 흔한 일이다. 중복 코드는 코드베이스를 비대하게 만들 뿐만 아니라 잠재적인 오류 지점이 만들어지게 된다.

중복 배제.. 일명 DRY 원칙이 도움이 된다. 공통 로직을 유틸리티 함수나 고차 컴포넌트(HOCs)로 중앙 집중화 함으로써 코드가 더 유지보수 가능하고 가독성이 높아지며 오류 발생 가능성이 줄어듭니다.

## 1.4.6 너무 많은 기능을 가진 컴포넌트

React는 모듈식의 재사용 가능한 컴포넌트 생성을 장려하지만, 기능이 추가됨에 따라 컴포넌트가 빠르게 크기와 책임을 키워 다루기 힘든 거대한 덩어리가 될 수 있다. - 다양한 작업을 관리하는 긴 컴포넌트는 유지보수, 이해, 테스트가 어려워집니다.

이러한 컴포넌트는 단일 책임원칙(SRP)를 위배한다. SRP는 컴포넌트가 오직 하나의 기능을 수행해야 한다고 주장한다.

## 1.4.7 안티패턴을 없애기 위한 접근 방식

pass
